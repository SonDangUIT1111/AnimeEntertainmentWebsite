
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AnimeepisodesComments
 * 
 */
export type AnimeepisodesComments = $Result.DefaultSelection<Prisma.$AnimeepisodesCommentsPayload>
/**
 * Model AnimeepisodesCommentsReplies
 * 
 */
export type AnimeepisodesCommentsReplies = $Result.DefaultSelection<Prisma.$AnimeepisodesCommentsRepliesPayload>
/**
 * Model BannersList
 * 
 */
export type BannersList = $Result.DefaultSelection<Prisma.$BannersListPayload>
/**
 * Model ComicchaptersComments
 * 
 */
export type ComicchaptersComments = $Result.DefaultSelection<Prisma.$ComicchaptersCommentsPayload>
/**
 * Model ComicchaptersCommentsReplies
 * 
 */
export type ComicchaptersCommentsReplies = $Result.DefaultSelection<Prisma.$ComicchaptersCommentsRepliesPayload>
/**
 * Model UsersAuthentication
 * 
 */
export type UsersAuthentication = $Result.DefaultSelection<Prisma.$UsersAuthenticationPayload>
/**
 * Model UsersBookmarkList
 * 
 */
export type UsersBookmarkList = $Result.DefaultSelection<Prisma.$UsersBookmarkListPayload>
/**
 * Model UsersHistories
 * 
 */
export type UsersHistories = $Result.DefaultSelection<Prisma.$UsersHistoriesPayload>
/**
 * Model animeepisodes
 * 
 */
export type animeepisodes = $Result.DefaultSelection<Prisma.$animeepisodesPayload>
/**
 * Model animes
 * 
 */
export type animes = $Result.DefaultSelection<Prisma.$animesPayload>
/**
 * Model banners
 * 
 */
export type banners = $Result.DefaultSelection<Prisma.$bannersPayload>
/**
 * Model comicalbums
 * 
 */
export type comicalbums = $Result.DefaultSelection<Prisma.$comicalbumsPayload>
/**
 * Model comicchapters
 * 
 */
export type comicchapters = $Result.DefaultSelection<Prisma.$comicchaptersPayload>
/**
 * Model comics
 * 
 */
export type comics = $Result.DefaultSelection<Prisma.$comicsPayload>
/**
 * Model genres
 * 
 */
export type genres = $Result.DefaultSelection<Prisma.$genresPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Animeepisodes
 * const animeepisodes = await prisma.animeepisodes.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Animeepisodes
   * const animeepisodes = await prisma.animeepisodes.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.animeepisodes`: Exposes CRUD operations for the **animeepisodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Animeepisodes
    * const animeepisodes = await prisma.animeepisodes.findMany()
    * ```
    */
  get animeepisodes(): Prisma.animeepisodesDelegate<ExtArgs>;

  /**
   * `prisma.animes`: Exposes CRUD operations for the **animes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Animes
    * const animes = await prisma.animes.findMany()
    * ```
    */
  get animes(): Prisma.animesDelegate<ExtArgs>;

  /**
   * `prisma.banners`: Exposes CRUD operations for the **banners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banners.findMany()
    * ```
    */
  get banners(): Prisma.bannersDelegate<ExtArgs>;

  /**
   * `prisma.comicalbums`: Exposes CRUD operations for the **comicalbums** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comicalbums
    * const comicalbums = await prisma.comicalbums.findMany()
    * ```
    */
  get comicalbums(): Prisma.comicalbumsDelegate<ExtArgs>;

  /**
   * `prisma.comicchapters`: Exposes CRUD operations for the **comicchapters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comicchapters
    * const comicchapters = await prisma.comicchapters.findMany()
    * ```
    */
  get comicchapters(): Prisma.comicchaptersDelegate<ExtArgs>;

  /**
   * `prisma.comics`: Exposes CRUD operations for the **comics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comics
    * const comics = await prisma.comics.findMany()
    * ```
    */
  get comics(): Prisma.comicsDelegate<ExtArgs>;

  /**
   * `prisma.genres`: Exposes CRUD operations for the **genres** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genres.findMany()
    * ```
    */
  get genres(): Prisma.genresDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.13.0
   * Query Engine version: b9a39a7ee606c28e3455d0fd60e78c3ba82b1a2b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    animeepisodes: 'animeepisodes',
    animes: 'animes',
    banners: 'banners',
    comicalbums: 'comicalbums',
    comicchapters: 'comicchapters',
    comics: 'comics',
    genres: 'genres',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'animeepisodes' | 'animes' | 'banners' | 'comicalbums' | 'comicchapters' | 'comics' | 'genres' | 'users'
      txIsolationLevel: never
    },
    model: {
      animeepisodes: {
        payload: Prisma.$animeepisodesPayload<ExtArgs>
        fields: Prisma.animeepisodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.animeepisodesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.animeepisodesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          findFirst: {
            args: Prisma.animeepisodesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.animeepisodesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          findMany: {
            args: Prisma.animeepisodesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>[]
          }
          create: {
            args: Prisma.animeepisodesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          createMany: {
            args: Prisma.animeepisodesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.animeepisodesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          update: {
            args: Prisma.animeepisodesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          deleteMany: {
            args: Prisma.animeepisodesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.animeepisodesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.animeepisodesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animeepisodesPayload>
          }
          aggregate: {
            args: Prisma.AnimeepisodesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnimeepisodes>
          }
          groupBy: {
            args: Prisma.animeepisodesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnimeepisodesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.animeepisodesFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.animeepisodesAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.animeepisodesCountArgs<ExtArgs>,
            result: $Utils.Optional<AnimeepisodesCountAggregateOutputType> | number
          }
        }
      }
      animes: {
        payload: Prisma.$animesPayload<ExtArgs>
        fields: Prisma.animesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.animesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.animesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          findFirst: {
            args: Prisma.animesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.animesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          findMany: {
            args: Prisma.animesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>[]
          }
          create: {
            args: Prisma.animesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          createMany: {
            args: Prisma.animesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.animesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          update: {
            args: Prisma.animesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          deleteMany: {
            args: Prisma.animesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.animesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.animesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animesPayload>
          }
          aggregate: {
            args: Prisma.AnimesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnimes>
          }
          groupBy: {
            args: Prisma.animesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnimesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.animesFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.animesAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.animesCountArgs<ExtArgs>,
            result: $Utils.Optional<AnimesCountAggregateOutputType> | number
          }
        }
      }
      banners: {
        payload: Prisma.$bannersPayload<ExtArgs>
        fields: Prisma.bannersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bannersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bannersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          findFirst: {
            args: Prisma.bannersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bannersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          findMany: {
            args: Prisma.bannersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>[]
          }
          create: {
            args: Prisma.bannersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          createMany: {
            args: Prisma.bannersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bannersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          update: {
            args: Prisma.bannersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          deleteMany: {
            args: Prisma.bannersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bannersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bannersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bannersPayload>
          }
          aggregate: {
            args: Prisma.BannersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanners>
          }
          groupBy: {
            args: Prisma.bannersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BannersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.bannersFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.bannersAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.bannersCountArgs<ExtArgs>,
            result: $Utils.Optional<BannersCountAggregateOutputType> | number
          }
        }
      }
      comicalbums: {
        payload: Prisma.$comicalbumsPayload<ExtArgs>
        fields: Prisma.comicalbumsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comicalbumsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comicalbumsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          findFirst: {
            args: Prisma.comicalbumsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comicalbumsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          findMany: {
            args: Prisma.comicalbumsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>[]
          }
          create: {
            args: Prisma.comicalbumsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          createMany: {
            args: Prisma.comicalbumsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comicalbumsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          update: {
            args: Prisma.comicalbumsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          deleteMany: {
            args: Prisma.comicalbumsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comicalbumsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comicalbumsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicalbumsPayload>
          }
          aggregate: {
            args: Prisma.ComicalbumsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComicalbums>
          }
          groupBy: {
            args: Prisma.comicalbumsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComicalbumsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.comicalbumsFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.comicalbumsAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.comicalbumsCountArgs<ExtArgs>,
            result: $Utils.Optional<ComicalbumsCountAggregateOutputType> | number
          }
        }
      }
      comicchapters: {
        payload: Prisma.$comicchaptersPayload<ExtArgs>
        fields: Prisma.comicchaptersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comicchaptersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comicchaptersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          findFirst: {
            args: Prisma.comicchaptersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comicchaptersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          findMany: {
            args: Prisma.comicchaptersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>[]
          }
          create: {
            args: Prisma.comicchaptersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          createMany: {
            args: Prisma.comicchaptersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comicchaptersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          update: {
            args: Prisma.comicchaptersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          deleteMany: {
            args: Prisma.comicchaptersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comicchaptersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comicchaptersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicchaptersPayload>
          }
          aggregate: {
            args: Prisma.ComicchaptersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComicchapters>
          }
          groupBy: {
            args: Prisma.comicchaptersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComicchaptersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.comicchaptersFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.comicchaptersAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.comicchaptersCountArgs<ExtArgs>,
            result: $Utils.Optional<ComicchaptersCountAggregateOutputType> | number
          }
        }
      }
      comics: {
        payload: Prisma.$comicsPayload<ExtArgs>
        fields: Prisma.comicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comicsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comicsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          findFirst: {
            args: Prisma.comicsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comicsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          findMany: {
            args: Prisma.comicsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>[]
          }
          create: {
            args: Prisma.comicsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          createMany: {
            args: Prisma.comicsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comicsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          update: {
            args: Prisma.comicsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          deleteMany: {
            args: Prisma.comicsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comicsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comicsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comicsPayload>
          }
          aggregate: {
            args: Prisma.ComicsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComics>
          }
          groupBy: {
            args: Prisma.comicsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComicsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.comicsFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.comicsAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.comicsCountArgs<ExtArgs>,
            result: $Utils.Optional<ComicsCountAggregateOutputType> | number
          }
        }
      }
      genres: {
        payload: Prisma.$genresPayload<ExtArgs>
        fields: Prisma.genresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.genresFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.genresFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          findFirst: {
            args: Prisma.genresFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.genresFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          findMany: {
            args: Prisma.genresFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>[]
          }
          create: {
            args: Prisma.genresCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          createMany: {
            args: Prisma.genresCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.genresDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          update: {
            args: Prisma.genresUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          deleteMany: {
            args: Prisma.genresDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.genresUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.genresUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$genresPayload>
          }
          aggregate: {
            args: Prisma.GenresAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGenres>
          }
          groupBy: {
            args: Prisma.genresGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GenresGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.genresFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.genresAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.genresCountArgs<ExtArgs>,
            result: $Utils.Optional<GenresCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model AnimeepisodesComments
   */





  export type AnimeepisodesCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content?: boolean
    likes?: boolean
    replies?: boolean | AnimeepisodesCommentsRepliesDefaultArgs<ExtArgs>
    userId?: boolean
  }, ExtArgs["result"]["animeepisodesComments"]>

  export type AnimeepisodesCommentsSelectScalar = {
    content?: boolean
    likes?: boolean
    userId?: boolean
  }


  export type AnimeepisodesCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $AnimeepisodesCommentsPayload = {
    name: "AnimeepisodesComments"
    objects: {}
    scalars: {
      content: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      userId: string
    }
    composites: {
      replies: Prisma.$AnimeepisodesCommentsRepliesPayload[]
    }
  }


  type AnimeepisodesCommentsGetPayload<S extends boolean | null | undefined | AnimeepisodesCommentsDefaultArgs> = $Result.GetResult<Prisma.$AnimeepisodesCommentsPayload, S>





  /**
   * Fields of the AnimeepisodesComments model
   */ 
  interface AnimeepisodesCommentsFieldRefs {
    readonly content: FieldRef<"AnimeepisodesComments", 'String'>
    readonly likes: FieldRef<"AnimeepisodesComments", 'Json'>
    readonly userId: FieldRef<"AnimeepisodesComments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnimeepisodesComments without action
   */
  export type AnimeepisodesCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeepisodesComments
     */
    select?: AnimeepisodesCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeepisodesCommentsInclude<ExtArgs> | null
  }


  /**
   * Model AnimeepisodesCommentsReplies
   */





  export type AnimeepisodesCommentsRepliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content?: boolean
    likes?: boolean
    replies?: boolean
    userId?: boolean
  }, ExtArgs["result"]["animeepisodesCommentsReplies"]>

  export type AnimeepisodesCommentsRepliesSelectScalar = {
    content?: boolean
    likes?: boolean
    replies?: boolean
    userId?: boolean
  }



  export type $AnimeepisodesCommentsRepliesPayload = {
    name: "AnimeepisodesCommentsReplies"
    objects: {}
    scalars: {
      content: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      replies: Prisma.JsonValue | null
      userId: string
    }
    composites: {}
  }


  type AnimeepisodesCommentsRepliesGetPayload<S extends boolean | null | undefined | AnimeepisodesCommentsRepliesDefaultArgs> = $Result.GetResult<Prisma.$AnimeepisodesCommentsRepliesPayload, S>





  /**
   * Fields of the AnimeepisodesCommentsReplies model
   */ 
  interface AnimeepisodesCommentsRepliesFieldRefs {
    readonly content: FieldRef<"AnimeepisodesCommentsReplies", 'String'>
    readonly likes: FieldRef<"AnimeepisodesCommentsReplies", 'Json'>
    readonly replies: FieldRef<"AnimeepisodesCommentsReplies", 'Json'>
    readonly userId: FieldRef<"AnimeepisodesCommentsReplies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnimeepisodesCommentsReplies without action
   */
  export type AnimeepisodesCommentsRepliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeepisodesCommentsReplies
     */
    select?: AnimeepisodesCommentsRepliesSelect<ExtArgs> | null
  }


  /**
   * Model BannersList
   */





  export type BannersListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bannerImage?: boolean
    urlId?: boolean
  }, ExtArgs["result"]["bannersList"]>

  export type BannersListSelectScalar = {
    bannerImage?: boolean
    urlId?: boolean
  }



  export type $BannersListPayload = {
    name: "BannersList"
    objects: {}
    scalars: {
      bannerImage: string
      urlId: string
    }
    composites: {}
  }


  type BannersListGetPayload<S extends boolean | null | undefined | BannersListDefaultArgs> = $Result.GetResult<Prisma.$BannersListPayload, S>





  /**
   * Fields of the BannersList model
   */ 
  interface BannersListFieldRefs {
    readonly bannerImage: FieldRef<"BannersList", 'String'>
    readonly urlId: FieldRef<"BannersList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BannersList without action
   */
  export type BannersListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BannersList
     */
    select?: BannersListSelect<ExtArgs> | null
  }


  /**
   * Model ComicchaptersComments
   */





  export type ComicchaptersCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content?: boolean
    likes?: boolean
    replies?: boolean | ComicchaptersCommentsRepliesDefaultArgs<ExtArgs>
    userId?: boolean
  }, ExtArgs["result"]["comicchaptersComments"]>

  export type ComicchaptersCommentsSelectScalar = {
    content?: boolean
    likes?: boolean
    userId?: boolean
  }


  export type ComicchaptersCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $ComicchaptersCommentsPayload = {
    name: "ComicchaptersComments"
    objects: {}
    scalars: {
      content: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      userId: string
    }
    composites: {
      replies: Prisma.$ComicchaptersCommentsRepliesPayload[]
    }
  }


  type ComicchaptersCommentsGetPayload<S extends boolean | null | undefined | ComicchaptersCommentsDefaultArgs> = $Result.GetResult<Prisma.$ComicchaptersCommentsPayload, S>





  /**
   * Fields of the ComicchaptersComments model
   */ 
  interface ComicchaptersCommentsFieldRefs {
    readonly content: FieldRef<"ComicchaptersComments", 'String'>
    readonly likes: FieldRef<"ComicchaptersComments", 'Json'>
    readonly userId: FieldRef<"ComicchaptersComments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComicchaptersComments without action
   */
  export type ComicchaptersCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComicchaptersComments
     */
    select?: ComicchaptersCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComicchaptersCommentsInclude<ExtArgs> | null
  }


  /**
   * Model ComicchaptersCommentsReplies
   */





  export type ComicchaptersCommentsRepliesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    content?: boolean
    likes?: boolean
    replies?: boolean
    userId?: boolean
  }, ExtArgs["result"]["comicchaptersCommentsReplies"]>

  export type ComicchaptersCommentsRepliesSelectScalar = {
    content?: boolean
    likes?: boolean
    replies?: boolean
    userId?: boolean
  }



  export type $ComicchaptersCommentsRepliesPayload = {
    name: "ComicchaptersCommentsReplies"
    objects: {}
    scalars: {
      content: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      replies: Prisma.JsonValue | null
      userId: string
    }
    composites: {}
  }


  type ComicchaptersCommentsRepliesGetPayload<S extends boolean | null | undefined | ComicchaptersCommentsRepliesDefaultArgs> = $Result.GetResult<Prisma.$ComicchaptersCommentsRepliesPayload, S>





  /**
   * Fields of the ComicchaptersCommentsReplies model
   */ 
  interface ComicchaptersCommentsRepliesFieldRefs {
    readonly content: FieldRef<"ComicchaptersCommentsReplies", 'String'>
    readonly likes: FieldRef<"ComicchaptersCommentsReplies", 'Json'>
    readonly replies: FieldRef<"ComicchaptersCommentsReplies", 'Json'>
    readonly userId: FieldRef<"ComicchaptersCommentsReplies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComicchaptersCommentsReplies without action
   */
  export type ComicchaptersCommentsRepliesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComicchaptersCommentsReplies
     */
    select?: ComicchaptersCommentsRepliesSelect<ExtArgs> | null
  }


  /**
   * Model UsersAuthentication
   */





  export type UsersAuthenticationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    password?: boolean
    salt?: boolean
    sessionToken?: boolean
  }, ExtArgs["result"]["usersAuthentication"]>

  export type UsersAuthenticationSelectScalar = {
    password?: boolean
    salt?: boolean
    sessionToken?: boolean
  }



  export type $UsersAuthenticationPayload = {
    name: "UsersAuthentication"
    objects: {}
    scalars: {
      password: string
      salt: string
      sessionToken: string
    }
    composites: {}
  }


  type UsersAuthenticationGetPayload<S extends boolean | null | undefined | UsersAuthenticationDefaultArgs> = $Result.GetResult<Prisma.$UsersAuthenticationPayload, S>





  /**
   * Fields of the UsersAuthentication model
   */ 
  interface UsersAuthenticationFieldRefs {
    readonly password: FieldRef<"UsersAuthentication", 'String'>
    readonly salt: FieldRef<"UsersAuthentication", 'String'>
    readonly sessionToken: FieldRef<"UsersAuthentication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsersAuthentication without action
   */
  export type UsersAuthenticationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuthentication
     */
    select?: UsersAuthenticationSelect<ExtArgs> | null
  }


  /**
   * Model UsersBookmarkList
   */





  export type UsersBookmarkListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comic?: boolean
    movies?: boolean
  }, ExtArgs["result"]["usersBookmarkList"]>

  export type UsersBookmarkListSelectScalar = {
    comic?: boolean
    movies?: boolean
  }



  export type $UsersBookmarkListPayload = {
    name: "UsersBookmarkList"
    objects: {}
    scalars: {
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      comic: Prisma.JsonValue | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      movies: Prisma.JsonValue | null
    }
    composites: {}
  }


  type UsersBookmarkListGetPayload<S extends boolean | null | undefined | UsersBookmarkListDefaultArgs> = $Result.GetResult<Prisma.$UsersBookmarkListPayload, S>





  /**
   * Fields of the UsersBookmarkList model
   */ 
  interface UsersBookmarkListFieldRefs {
    readonly comic: FieldRef<"UsersBookmarkList", 'Json'>
    readonly movies: FieldRef<"UsersBookmarkList", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UsersBookmarkList without action
   */
  export type UsersBookmarkListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersBookmarkList
     */
    select?: UsersBookmarkListSelect<ExtArgs> | null
  }


  /**
   * Model UsersHistories
   */





  export type UsersHistoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    readingComic?: boolean
    watchingMovie?: boolean
  }, ExtArgs["result"]["usersHistories"]>

  export type UsersHistoriesSelectScalar = {
    readingComic?: boolean
    watchingMovie?: boolean
  }



  export type $UsersHistoriesPayload = {
    name: "UsersHistories"
    objects: {}
    scalars: {
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      readingComic: Prisma.JsonValue | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      watchingMovie: Prisma.JsonValue | null
    }
    composites: {}
  }


  type UsersHistoriesGetPayload<S extends boolean | null | undefined | UsersHistoriesDefaultArgs> = $Result.GetResult<Prisma.$UsersHistoriesPayload, S>





  /**
   * Fields of the UsersHistories model
   */ 
  interface UsersHistoriesFieldRefs {
    readonly readingComic: FieldRef<"UsersHistories", 'Json'>
    readonly watchingMovie: FieldRef<"UsersHistories", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UsersHistories without action
   */
  export type UsersHistoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersHistories
     */
    select?: UsersHistoriesSelect<ExtArgs> | null
  }


  /**
   * Model animeepisodes
   */

  export type AggregateAnimeepisodes = {
    _count: AnimeepisodesCountAggregateOutputType | null
    _avg: AnimeepisodesAvgAggregateOutputType | null
    _sum: AnimeepisodesSumAggregateOutputType | null
    _min: AnimeepisodesMinAggregateOutputType | null
    _max: AnimeepisodesMaxAggregateOutputType | null
  }

  export type AnimeepisodesAvgAggregateOutputType = {
    totalTime: number | null
    views: number | null
  }

  export type AnimeepisodesSumAggregateOutputType = {
    totalTime: number | null
    views: number | null
  }

  export type AnimeepisodesMinAggregateOutputType = {
    id: string | null
    adLink: string | null
    advertising: string | null
    content: string | null
    coverImage: string | null
    episodeName: string | null
    publicTime: Date | null
    totalTime: number | null
    views: number | null
  }

  export type AnimeepisodesMaxAggregateOutputType = {
    id: string | null
    adLink: string | null
    advertising: string | null
    content: string | null
    coverImage: string | null
    episodeName: string | null
    publicTime: Date | null
    totalTime: number | null
    views: number | null
  }

  export type AnimeepisodesCountAggregateOutputType = {
    id: number
    adLink: number
    advertising: number
    content: number
    coverImage: number
    episodeName: number
    likes: number
    publicTime: number
    totalTime: number
    views: number
    _all: number
  }


  export type AnimeepisodesAvgAggregateInputType = {
    totalTime?: true
    views?: true
  }

  export type AnimeepisodesSumAggregateInputType = {
    totalTime?: true
    views?: true
  }

  export type AnimeepisodesMinAggregateInputType = {
    id?: true
    adLink?: true
    advertising?: true
    content?: true
    coverImage?: true
    episodeName?: true
    publicTime?: true
    totalTime?: true
    views?: true
  }

  export type AnimeepisodesMaxAggregateInputType = {
    id?: true
    adLink?: true
    advertising?: true
    content?: true
    coverImage?: true
    episodeName?: true
    publicTime?: true
    totalTime?: true
    views?: true
  }

  export type AnimeepisodesCountAggregateInputType = {
    id?: true
    adLink?: true
    advertising?: true
    content?: true
    coverImage?: true
    episodeName?: true
    likes?: true
    publicTime?: true
    totalTime?: true
    views?: true
    _all?: true
  }

  export type AnimeepisodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which animeepisodes to aggregate.
     */
    where?: animeepisodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animeepisodes to fetch.
     */
    orderBy?: animeepisodesOrderByWithRelationInput | animeepisodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: animeepisodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animeepisodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animeepisodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned animeepisodes
    **/
    _count?: true | AnimeepisodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimeepisodesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimeepisodesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimeepisodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimeepisodesMaxAggregateInputType
  }

  export type GetAnimeepisodesAggregateType<T extends AnimeepisodesAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimeepisodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimeepisodes[P]>
      : GetScalarType<T[P], AggregateAnimeepisodes[P]>
  }




  export type animeepisodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: animeepisodesWhereInput
    orderBy?: animeepisodesOrderByWithAggregationInput | animeepisodesOrderByWithAggregationInput[]
    by: AnimeepisodesScalarFieldEnum[] | AnimeepisodesScalarFieldEnum
    having?: animeepisodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimeepisodesCountAggregateInputType | true
    _avg?: AnimeepisodesAvgAggregateInputType
    _sum?: AnimeepisodesSumAggregateInputType
    _min?: AnimeepisodesMinAggregateInputType
    _max?: AnimeepisodesMaxAggregateInputType
  }

  export type AnimeepisodesGroupByOutputType = {
    id: string
    adLink: string
    advertising: string
    content: string
    coverImage: string
    episodeName: string
    likes: JsonValue | null
    publicTime: Date
    totalTime: number
    views: number
    _count: AnimeepisodesCountAggregateOutputType | null
    _avg: AnimeepisodesAvgAggregateOutputType | null
    _sum: AnimeepisodesSumAggregateOutputType | null
    _min: AnimeepisodesMinAggregateOutputType | null
    _max: AnimeepisodesMaxAggregateOutputType | null
  }

  type GetAnimeepisodesGroupByPayload<T extends animeepisodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimeepisodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimeepisodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimeepisodesGroupByOutputType[P]>
            : GetScalarType<T[P], AnimeepisodesGroupByOutputType[P]>
        }
      >
    >


  export type animeepisodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adLink?: boolean
    advertising?: boolean
    comments?: boolean | AnimeepisodesCommentsDefaultArgs<ExtArgs>
    content?: boolean
    coverImage?: boolean
    episodeName?: boolean
    likes?: boolean
    publicTime?: boolean
    totalTime?: boolean
    views?: boolean
  }, ExtArgs["result"]["animeepisodes"]>

  export type animeepisodesSelectScalar = {
    id?: boolean
    adLink?: boolean
    advertising?: boolean
    content?: boolean
    coverImage?: boolean
    episodeName?: boolean
    likes?: boolean
    publicTime?: boolean
    totalTime?: boolean
    views?: boolean
  }


  export type animeepisodesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $animeepisodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "animeepisodes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adLink: string
      advertising: string
      content: string
      coverImage: string
      episodeName: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      publicTime: Date
      totalTime: number
      views: number
    }, ExtArgs["result"]["animeepisodes"]>
    composites: {
      comments: Prisma.$AnimeepisodesCommentsPayload[]
    }
  }


  type animeepisodesGetPayload<S extends boolean | null | undefined | animeepisodesDefaultArgs> = $Result.GetResult<Prisma.$animeepisodesPayload, S>

  type animeepisodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<animeepisodesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnimeepisodesCountAggregateInputType | true
    }

  export interface animeepisodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['animeepisodes'], meta: { name: 'animeepisodes' } }
    /**
     * Find zero or one Animeepisodes that matches the filter.
     * @param {animeepisodesFindUniqueArgs} args - Arguments to find a Animeepisodes
     * @example
     * // Get one Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends animeepisodesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesFindUniqueArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Animeepisodes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {animeepisodesFindUniqueOrThrowArgs} args - Arguments to find a Animeepisodes
     * @example
     * // Get one Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends animeepisodesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Animeepisodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesFindFirstArgs} args - Arguments to find a Animeepisodes
     * @example
     * // Get one Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends animeepisodesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesFindFirstArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Animeepisodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesFindFirstOrThrowArgs} args - Arguments to find a Animeepisodes
     * @example
     * // Get one Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends animeepisodesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Animeepisodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findMany()
     * 
     * // Get first 10 Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animeepisodesWithIdOnly = await prisma.animeepisodes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends animeepisodesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Animeepisodes.
     * @param {animeepisodesCreateArgs} args - Arguments to create a Animeepisodes.
     * @example
     * // Create one Animeepisodes
     * const Animeepisodes = await prisma.animeepisodes.create({
     *   data: {
     *     // ... data to create a Animeepisodes
     *   }
     * })
     * 
    **/
    create<T extends animeepisodesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesCreateArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Animeepisodes.
     *     @param {animeepisodesCreateManyArgs} args - Arguments to create many Animeepisodes.
     *     @example
     *     // Create many Animeepisodes
     *     const animeepisodes = await prisma.animeepisodes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends animeepisodesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Animeepisodes.
     * @param {animeepisodesDeleteArgs} args - Arguments to delete one Animeepisodes.
     * @example
     * // Delete one Animeepisodes
     * const Animeepisodes = await prisma.animeepisodes.delete({
     *   where: {
     *     // ... filter to delete one Animeepisodes
     *   }
     * })
     * 
    **/
    delete<T extends animeepisodesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesDeleteArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Animeepisodes.
     * @param {animeepisodesUpdateArgs} args - Arguments to update one Animeepisodes.
     * @example
     * // Update one Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends animeepisodesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesUpdateArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Animeepisodes.
     * @param {animeepisodesDeleteManyArgs} args - Arguments to filter Animeepisodes to delete.
     * @example
     * // Delete a few Animeepisodes
     * const { count } = await prisma.animeepisodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends animeepisodesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeepisodesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Animeepisodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends animeepisodesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Animeepisodes.
     * @param {animeepisodesUpsertArgs} args - Arguments to update or create a Animeepisodes.
     * @example
     * // Update or create a Animeepisodes
     * const animeepisodes = await prisma.animeepisodes.upsert({
     *   create: {
     *     // ... data to create a Animeepisodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Animeepisodes we want to update
     *   }
     * })
    **/
    upsert<T extends animeepisodesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, animeepisodesUpsertArgs<ExtArgs>>
    ): Prisma__animeepisodesClient<$Result.GetResult<Prisma.$animeepisodesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Animeepisodes that matches the filter.
     * @param {animeepisodesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const animeepisodes = await prisma.animeepisodes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: animeepisodesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Animeepisodes.
     * @param {animeepisodesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const animeepisodes = await prisma.animeepisodes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: animeepisodesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Animeepisodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesCountArgs} args - Arguments to filter Animeepisodes to count.
     * @example
     * // Count the number of Animeepisodes
     * const count = await prisma.animeepisodes.count({
     *   where: {
     *     // ... the filter for the Animeepisodes we want to count
     *   }
     * })
    **/
    count<T extends animeepisodesCountArgs>(
      args?: Subset<T, animeepisodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimeepisodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Animeepisodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeepisodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimeepisodesAggregateArgs>(args: Subset<T, AnimeepisodesAggregateArgs>): Prisma.PrismaPromise<GetAnimeepisodesAggregateType<T>>

    /**
     * Group by Animeepisodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeepisodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends animeepisodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: animeepisodesGroupByArgs['orderBy'] }
        : { orderBy?: animeepisodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, animeepisodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimeepisodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the animeepisodes model
   */
  readonly fields: animeepisodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for animeepisodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__animeepisodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the animeepisodes model
   */ 
  interface animeepisodesFieldRefs {
    readonly id: FieldRef<"animeepisodes", 'String'>
    readonly adLink: FieldRef<"animeepisodes", 'String'>
    readonly advertising: FieldRef<"animeepisodes", 'String'>
    readonly content: FieldRef<"animeepisodes", 'String'>
    readonly coverImage: FieldRef<"animeepisodes", 'String'>
    readonly episodeName: FieldRef<"animeepisodes", 'String'>
    readonly likes: FieldRef<"animeepisodes", 'Json'>
    readonly publicTime: FieldRef<"animeepisodes", 'DateTime'>
    readonly totalTime: FieldRef<"animeepisodes", 'Int'>
    readonly views: FieldRef<"animeepisodes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * animeepisodes findUnique
   */
  export type animeepisodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter, which animeepisodes to fetch.
     */
    where: animeepisodesWhereUniqueInput
  }

  /**
   * animeepisodes findUniqueOrThrow
   */
  export type animeepisodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter, which animeepisodes to fetch.
     */
    where: animeepisodesWhereUniqueInput
  }

  /**
   * animeepisodes findFirst
   */
  export type animeepisodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter, which animeepisodes to fetch.
     */
    where?: animeepisodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animeepisodes to fetch.
     */
    orderBy?: animeepisodesOrderByWithRelationInput | animeepisodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for animeepisodes.
     */
    cursor?: animeepisodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animeepisodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animeepisodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of animeepisodes.
     */
    distinct?: AnimeepisodesScalarFieldEnum | AnimeepisodesScalarFieldEnum[]
  }

  /**
   * animeepisodes findFirstOrThrow
   */
  export type animeepisodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter, which animeepisodes to fetch.
     */
    where?: animeepisodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animeepisodes to fetch.
     */
    orderBy?: animeepisodesOrderByWithRelationInput | animeepisodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for animeepisodes.
     */
    cursor?: animeepisodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animeepisodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animeepisodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of animeepisodes.
     */
    distinct?: AnimeepisodesScalarFieldEnum | AnimeepisodesScalarFieldEnum[]
  }

  /**
   * animeepisodes findMany
   */
  export type animeepisodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter, which animeepisodes to fetch.
     */
    where?: animeepisodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animeepisodes to fetch.
     */
    orderBy?: animeepisodesOrderByWithRelationInput | animeepisodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing animeepisodes.
     */
    cursor?: animeepisodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animeepisodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animeepisodes.
     */
    skip?: number
    distinct?: AnimeepisodesScalarFieldEnum | AnimeepisodesScalarFieldEnum[]
  }

  /**
   * animeepisodes create
   */
  export type animeepisodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * The data needed to create a animeepisodes.
     */
    data: XOR<animeepisodesCreateInput, animeepisodesUncheckedCreateInput>
  }

  /**
   * animeepisodes createMany
   */
  export type animeepisodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many animeepisodes.
     */
    data: animeepisodesCreateManyInput | animeepisodesCreateManyInput[]
  }

  /**
   * animeepisodes update
   */
  export type animeepisodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * The data needed to update a animeepisodes.
     */
    data: XOR<animeepisodesUpdateInput, animeepisodesUncheckedUpdateInput>
    /**
     * Choose, which animeepisodes to update.
     */
    where: animeepisodesWhereUniqueInput
  }

  /**
   * animeepisodes updateMany
   */
  export type animeepisodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update animeepisodes.
     */
    data: XOR<animeepisodesUpdateManyMutationInput, animeepisodesUncheckedUpdateManyInput>
    /**
     * Filter which animeepisodes to update
     */
    where?: animeepisodesWhereInput
  }

  /**
   * animeepisodes upsert
   */
  export type animeepisodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * The filter to search for the animeepisodes to update in case it exists.
     */
    where: animeepisodesWhereUniqueInput
    /**
     * In case the animeepisodes found by the `where` argument doesn't exist, create a new animeepisodes with this data.
     */
    create: XOR<animeepisodesCreateInput, animeepisodesUncheckedCreateInput>
    /**
     * In case the animeepisodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<animeepisodesUpdateInput, animeepisodesUncheckedUpdateInput>
  }

  /**
   * animeepisodes delete
   */
  export type animeepisodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
    /**
     * Filter which animeepisodes to delete.
     */
    where: animeepisodesWhereUniqueInput
  }

  /**
   * animeepisodes deleteMany
   */
  export type animeepisodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which animeepisodes to delete
     */
    where?: animeepisodesWhereInput
  }

  /**
   * animeepisodes findRaw
   */
  export type animeepisodesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * animeepisodes aggregateRaw
   */
  export type animeepisodesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * animeepisodes without action
   */
  export type animeepisodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animeepisodes
     */
    select?: animeepisodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: animeepisodesInclude<ExtArgs> | null
  }


  /**
   * Model animes
   */

  export type AggregateAnimes = {
    _count: AnimesCountAggregateOutputType | null
    _min: AnimesMinAggregateOutputType | null
    _max: AnimesMaxAggregateOutputType | null
  }

  export type AnimesMinAggregateOutputType = {
    id: string | null
    ageFor: string | null
    coverImage: string | null
    description: string | null
    landspaceImage: string | null
    movieName: string | null
    publishTime: string | null
    publisher: string | null
  }

  export type AnimesMaxAggregateOutputType = {
    id: string | null
    ageFor: string | null
    coverImage: string | null
    description: string | null
    landspaceImage: string | null
    movieName: string | null
    publishTime: string | null
    publisher: string | null
  }

  export type AnimesCountAggregateOutputType = {
    id: number
    ageFor: number
    coverImage: number
    description: number
    episodes: number
    genres: number
    landspaceImage: number
    movieName: number
    publishTime: number
    publisher: number
    _all: number
  }


  export type AnimesMinAggregateInputType = {
    id?: true
    ageFor?: true
    coverImage?: true
    description?: true
    landspaceImage?: true
    movieName?: true
    publishTime?: true
    publisher?: true
  }

  export type AnimesMaxAggregateInputType = {
    id?: true
    ageFor?: true
    coverImage?: true
    description?: true
    landspaceImage?: true
    movieName?: true
    publishTime?: true
    publisher?: true
  }

  export type AnimesCountAggregateInputType = {
    id?: true
    ageFor?: true
    coverImage?: true
    description?: true
    episodes?: true
    genres?: true
    landspaceImage?: true
    movieName?: true
    publishTime?: true
    publisher?: true
    _all?: true
  }

  export type AnimesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which animes to aggregate.
     */
    where?: animesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animes to fetch.
     */
    orderBy?: animesOrderByWithRelationInput | animesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: animesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned animes
    **/
    _count?: true | AnimesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimesMaxAggregateInputType
  }

  export type GetAnimesAggregateType<T extends AnimesAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimes[P]>
      : GetScalarType<T[P], AggregateAnimes[P]>
  }




  export type animesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: animesWhereInput
    orderBy?: animesOrderByWithAggregationInput | animesOrderByWithAggregationInput[]
    by: AnimesScalarFieldEnum[] | AnimesScalarFieldEnum
    having?: animesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimesCountAggregateInputType | true
    _min?: AnimesMinAggregateInputType
    _max?: AnimesMaxAggregateInputType
  }

  export type AnimesGroupByOutputType = {
    id: string
    ageFor: string
    coverImage: string
    description: string
    episodes: string[]
    genres: string[]
    landspaceImage: string
    movieName: string
    publishTime: string
    publisher: string
    _count: AnimesCountAggregateOutputType | null
    _min: AnimesMinAggregateOutputType | null
    _max: AnimesMaxAggregateOutputType | null
  }

  type GetAnimesGroupByPayload<T extends animesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimesGroupByOutputType[P]>
            : GetScalarType<T[P], AnimesGroupByOutputType[P]>
        }
      >
    >


  export type animesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ageFor?: boolean
    coverImage?: boolean
    description?: boolean
    episodes?: boolean
    genres?: boolean
    landspaceImage?: boolean
    movieName?: boolean
    publishTime?: boolean
    publisher?: boolean
  }, ExtArgs["result"]["animes"]>

  export type animesSelectScalar = {
    id?: boolean
    ageFor?: boolean
    coverImage?: boolean
    description?: boolean
    episodes?: boolean
    genres?: boolean
    landspaceImage?: boolean
    movieName?: boolean
    publishTime?: boolean
    publisher?: boolean
  }



  export type $animesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "animes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ageFor: string
      coverImage: string
      description: string
      episodes: string[]
      genres: string[]
      landspaceImage: string
      movieName: string
      publishTime: string
      publisher: string
    }, ExtArgs["result"]["animes"]>
    composites: {}
  }


  type animesGetPayload<S extends boolean | null | undefined | animesDefaultArgs> = $Result.GetResult<Prisma.$animesPayload, S>

  type animesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<animesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnimesCountAggregateInputType | true
    }

  export interface animesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['animes'], meta: { name: 'animes' } }
    /**
     * Find zero or one Animes that matches the filter.
     * @param {animesFindUniqueArgs} args - Arguments to find a Animes
     * @example
     * // Get one Animes
     * const animes = await prisma.animes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends animesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, animesFindUniqueArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Animes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {animesFindUniqueOrThrowArgs} args - Arguments to find a Animes
     * @example
     * // Get one Animes
     * const animes = await prisma.animes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends animesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Animes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesFindFirstArgs} args - Arguments to find a Animes
     * @example
     * // Get one Animes
     * const animes = await prisma.animes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends animesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, animesFindFirstArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Animes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesFindFirstOrThrowArgs} args - Arguments to find a Animes
     * @example
     * // Get one Animes
     * const animes = await prisma.animes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends animesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Animes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Animes
     * const animes = await prisma.animes.findMany()
     * 
     * // Get first 10 Animes
     * const animes = await prisma.animes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animesWithIdOnly = await prisma.animes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends animesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Animes.
     * @param {animesCreateArgs} args - Arguments to create a Animes.
     * @example
     * // Create one Animes
     * const Animes = await prisma.animes.create({
     *   data: {
     *     // ... data to create a Animes
     *   }
     * })
     * 
    **/
    create<T extends animesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, animesCreateArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Animes.
     *     @param {animesCreateManyArgs} args - Arguments to create many Animes.
     *     @example
     *     // Create many Animes
     *     const animes = await prisma.animes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends animesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Animes.
     * @param {animesDeleteArgs} args - Arguments to delete one Animes.
     * @example
     * // Delete one Animes
     * const Animes = await prisma.animes.delete({
     *   where: {
     *     // ... filter to delete one Animes
     *   }
     * })
     * 
    **/
    delete<T extends animesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, animesDeleteArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Animes.
     * @param {animesUpdateArgs} args - Arguments to update one Animes.
     * @example
     * // Update one Animes
     * const animes = await prisma.animes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends animesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, animesUpdateArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Animes.
     * @param {animesDeleteManyArgs} args - Arguments to filter Animes to delete.
     * @example
     * // Delete a few Animes
     * const { count } = await prisma.animes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends animesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Animes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Animes
     * const animes = await prisma.animes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends animesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, animesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Animes.
     * @param {animesUpsertArgs} args - Arguments to update or create a Animes.
     * @example
     * // Update or create a Animes
     * const animes = await prisma.animes.upsert({
     *   create: {
     *     // ... data to create a Animes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Animes we want to update
     *   }
     * })
    **/
    upsert<T extends animesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, animesUpsertArgs<ExtArgs>>
    ): Prisma__animesClient<$Result.GetResult<Prisma.$animesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Animes that matches the filter.
     * @param {animesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const animes = await prisma.animes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: animesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Animes.
     * @param {animesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const animes = await prisma.animes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: animesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Animes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesCountArgs} args - Arguments to filter Animes to count.
     * @example
     * // Count the number of Animes
     * const count = await prisma.animes.count({
     *   where: {
     *     // ... the filter for the Animes we want to count
     *   }
     * })
    **/
    count<T extends animesCountArgs>(
      args?: Subset<T, animesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Animes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimesAggregateArgs>(args: Subset<T, AnimesAggregateArgs>): Prisma.PrismaPromise<GetAnimesAggregateType<T>>

    /**
     * Group by Animes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends animesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: animesGroupByArgs['orderBy'] }
        : { orderBy?: animesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, animesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the animes model
   */
  readonly fields: animesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for animes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__animesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the animes model
   */ 
  interface animesFieldRefs {
    readonly id: FieldRef<"animes", 'String'>
    readonly ageFor: FieldRef<"animes", 'String'>
    readonly coverImage: FieldRef<"animes", 'String'>
    readonly description: FieldRef<"animes", 'String'>
    readonly episodes: FieldRef<"animes", 'String[]'>
    readonly genres: FieldRef<"animes", 'String[]'>
    readonly landspaceImage: FieldRef<"animes", 'String'>
    readonly movieName: FieldRef<"animes", 'String'>
    readonly publishTime: FieldRef<"animes", 'String'>
    readonly publisher: FieldRef<"animes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * animes findUnique
   */
  export type animesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter, which animes to fetch.
     */
    where: animesWhereUniqueInput
  }

  /**
   * animes findUniqueOrThrow
   */
  export type animesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter, which animes to fetch.
     */
    where: animesWhereUniqueInput
  }

  /**
   * animes findFirst
   */
  export type animesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter, which animes to fetch.
     */
    where?: animesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animes to fetch.
     */
    orderBy?: animesOrderByWithRelationInput | animesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for animes.
     */
    cursor?: animesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of animes.
     */
    distinct?: AnimesScalarFieldEnum | AnimesScalarFieldEnum[]
  }

  /**
   * animes findFirstOrThrow
   */
  export type animesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter, which animes to fetch.
     */
    where?: animesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animes to fetch.
     */
    orderBy?: animesOrderByWithRelationInput | animesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for animes.
     */
    cursor?: animesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of animes.
     */
    distinct?: AnimesScalarFieldEnum | AnimesScalarFieldEnum[]
  }

  /**
   * animes findMany
   */
  export type animesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter, which animes to fetch.
     */
    where?: animesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of animes to fetch.
     */
    orderBy?: animesOrderByWithRelationInput | animesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing animes.
     */
    cursor?: animesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` animes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` animes.
     */
    skip?: number
    distinct?: AnimesScalarFieldEnum | AnimesScalarFieldEnum[]
  }

  /**
   * animes create
   */
  export type animesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * The data needed to create a animes.
     */
    data: XOR<animesCreateInput, animesUncheckedCreateInput>
  }

  /**
   * animes createMany
   */
  export type animesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many animes.
     */
    data: animesCreateManyInput | animesCreateManyInput[]
  }

  /**
   * animes update
   */
  export type animesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * The data needed to update a animes.
     */
    data: XOR<animesUpdateInput, animesUncheckedUpdateInput>
    /**
     * Choose, which animes to update.
     */
    where: animesWhereUniqueInput
  }

  /**
   * animes updateMany
   */
  export type animesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update animes.
     */
    data: XOR<animesUpdateManyMutationInput, animesUncheckedUpdateManyInput>
    /**
     * Filter which animes to update
     */
    where?: animesWhereInput
  }

  /**
   * animes upsert
   */
  export type animesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * The filter to search for the animes to update in case it exists.
     */
    where: animesWhereUniqueInput
    /**
     * In case the animes found by the `where` argument doesn't exist, create a new animes with this data.
     */
    create: XOR<animesCreateInput, animesUncheckedCreateInput>
    /**
     * In case the animes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<animesUpdateInput, animesUncheckedUpdateInput>
  }

  /**
   * animes delete
   */
  export type animesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
    /**
     * Filter which animes to delete.
     */
    where: animesWhereUniqueInput
  }

  /**
   * animes deleteMany
   */
  export type animesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which animes to delete
     */
    where?: animesWhereInput
  }

  /**
   * animes findRaw
   */
  export type animesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * animes aggregateRaw
   */
  export type animesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * animes without action
   */
  export type animesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the animes
     */
    select?: animesSelect<ExtArgs> | null
  }


  /**
   * Model banners
   */

  export type AggregateBanners = {
    _count: BannersCountAggregateOutputType | null
    _min: BannersMinAggregateOutputType | null
    _max: BannersMaxAggregateOutputType | null
  }

  export type BannersMinAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type BannersMaxAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type BannersCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type BannersMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type BannersMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type BannersCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type BannersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to aggregate.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banners
    **/
    _count?: true | BannersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannersMaxAggregateInputType
  }

  export type GetBannersAggregateType<T extends BannersAggregateArgs> = {
        [P in keyof T & keyof AggregateBanners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanners[P]>
      : GetScalarType<T[P], AggregateBanners[P]>
  }




  export type bannersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bannersWhereInput
    orderBy?: bannersOrderByWithAggregationInput | bannersOrderByWithAggregationInput[]
    by: BannersScalarFieldEnum[] | BannersScalarFieldEnum
    having?: bannersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannersCountAggregateInputType | true
    _min?: BannersMinAggregateInputType
    _max?: BannersMaxAggregateInputType
  }

  export type BannersGroupByOutputType = {
    id: string
    type: string
    _count: BannersCountAggregateOutputType | null
    _min: BannersMinAggregateOutputType | null
    _max: BannersMaxAggregateOutputType | null
  }

  type GetBannersGroupByPayload<T extends bannersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannersGroupByOutputType[P]>
            : GetScalarType<T[P], BannersGroupByOutputType[P]>
        }
      >
    >


  export type bannersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    list?: boolean | BannersListDefaultArgs<ExtArgs>
    type?: boolean
  }, ExtArgs["result"]["banners"]>

  export type bannersSelectScalar = {
    id?: boolean
    type?: boolean
  }


  export type bannersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $bannersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "banners"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
    }, ExtArgs["result"]["banners"]>
    composites: {
      list: Prisma.$BannersListPayload[]
    }
  }


  type bannersGetPayload<S extends boolean | null | undefined | bannersDefaultArgs> = $Result.GetResult<Prisma.$bannersPayload, S>

  type bannersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bannersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannersCountAggregateInputType | true
    }

  export interface bannersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banners'], meta: { name: 'banners' } }
    /**
     * Find zero or one Banners that matches the filter.
     * @param {bannersFindUniqueArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bannersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bannersFindUniqueArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banners that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bannersFindUniqueOrThrowArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bannersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindFirstArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bannersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersFindFirstArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindFirstOrThrowArgs} args - Arguments to find a Banners
     * @example
     * // Get one Banners
     * const banners = await prisma.banners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bannersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banners.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannersWithIdOnly = await prisma.banners.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bannersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banners.
     * @param {bannersCreateArgs} args - Arguments to create a Banners.
     * @example
     * // Create one Banners
     * const Banners = await prisma.banners.create({
     *   data: {
     *     // ... data to create a Banners
     *   }
     * })
     * 
    **/
    create<T extends bannersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bannersCreateArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banners.
     *     @param {bannersCreateManyArgs} args - Arguments to create many Banners.
     *     @example
     *     // Create many Banners
     *     const banners = await prisma.banners.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bannersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banners.
     * @param {bannersDeleteArgs} args - Arguments to delete one Banners.
     * @example
     * // Delete one Banners
     * const Banners = await prisma.banners.delete({
     *   where: {
     *     // ... filter to delete one Banners
     *   }
     * })
     * 
    **/
    delete<T extends bannersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bannersDeleteArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banners.
     * @param {bannersUpdateArgs} args - Arguments to update one Banners.
     * @example
     * // Update one Banners
     * const banners = await prisma.banners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bannersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bannersUpdateArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banners.
     * @param {bannersDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bannersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banners = await prisma.banners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bannersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bannersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banners.
     * @param {bannersUpsertArgs} args - Arguments to update or create a Banners.
     * @example
     * // Update or create a Banners
     * const banners = await prisma.banners.upsert({
     *   create: {
     *     // ... data to create a Banners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banners we want to update
     *   }
     * })
    **/
    upsert<T extends bannersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bannersUpsertArgs<ExtArgs>>
    ): Prisma__bannersClient<$Result.GetResult<Prisma.$bannersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * @param {bannersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const banners = await prisma.banners.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: bannersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Banners.
     * @param {bannersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const banners = await prisma.banners.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: bannersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banners.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends bannersCountArgs>(
      args?: Subset<T, bannersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannersAggregateArgs>(args: Subset<T, BannersAggregateArgs>): Prisma.PrismaPromise<GetBannersAggregateType<T>>

    /**
     * Group by Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bannersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bannersGroupByArgs['orderBy'] }
        : { orderBy?: bannersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bannersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banners model
   */
  readonly fields: bannersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bannersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the banners model
   */ 
  interface bannersFieldRefs {
    readonly id: FieldRef<"banners", 'String'>
    readonly type: FieldRef<"banners", 'String'>
  }
    

  // Custom InputTypes
  /**
   * banners findUnique
   */
  export type bannersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners findUniqueOrThrow
   */
  export type bannersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners findFirst
   */
  export type bannersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners findFirstOrThrow
   */
  export type bannersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners findMany
   */
  export type bannersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannersOrderByWithRelationInput | bannersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banners.
     */
    cursor?: bannersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    distinct?: BannersScalarFieldEnum | BannersScalarFieldEnum[]
  }

  /**
   * banners create
   */
  export type bannersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * The data needed to create a banners.
     */
    data: XOR<bannersCreateInput, bannersUncheckedCreateInput>
  }

  /**
   * banners createMany
   */
  export type bannersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banners.
     */
    data: bannersCreateManyInput | bannersCreateManyInput[]
  }

  /**
   * banners update
   */
  export type bannersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * The data needed to update a banners.
     */
    data: XOR<bannersUpdateInput, bannersUncheckedUpdateInput>
    /**
     * Choose, which banners to update.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners updateMany
   */
  export type bannersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banners.
     */
    data: XOR<bannersUpdateManyMutationInput, bannersUncheckedUpdateManyInput>
    /**
     * Filter which banners to update
     */
    where?: bannersWhereInput
  }

  /**
   * banners upsert
   */
  export type bannersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * The filter to search for the banners to update in case it exists.
     */
    where: bannersWhereUniqueInput
    /**
     * In case the banners found by the `where` argument doesn't exist, create a new banners with this data.
     */
    create: XOR<bannersCreateInput, bannersUncheckedCreateInput>
    /**
     * In case the banners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bannersUpdateInput, bannersUncheckedUpdateInput>
  }

  /**
   * banners delete
   */
  export type bannersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
    /**
     * Filter which banners to delete.
     */
    where: bannersWhereUniqueInput
  }

  /**
   * banners deleteMany
   */
  export type bannersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to delete
     */
    where?: bannersWhereInput
  }

  /**
   * banners findRaw
   */
  export type bannersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * banners aggregateRaw
   */
  export type bannersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * banners without action
   */
  export type bannersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banners
     */
    select?: bannersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bannersInclude<ExtArgs> | null
  }


  /**
   * Model comicalbums
   */

  export type AggregateComicalbums = {
    _count: ComicalbumsCountAggregateOutputType | null
    _min: ComicalbumsMinAggregateOutputType | null
    _max: ComicalbumsMaxAggregateOutputType | null
  }

  export type ComicalbumsMinAggregateOutputType = {
    id: string | null
    albumName: string | null
  }

  export type ComicalbumsMaxAggregateOutputType = {
    id: string | null
    albumName: string | null
  }

  export type ComicalbumsCountAggregateOutputType = {
    id: number
    albumName: number
    comicList: number
    _all: number
  }


  export type ComicalbumsMinAggregateInputType = {
    id?: true
    albumName?: true
  }

  export type ComicalbumsMaxAggregateInputType = {
    id?: true
    albumName?: true
  }

  export type ComicalbumsCountAggregateInputType = {
    id?: true
    albumName?: true
    comicList?: true
    _all?: true
  }

  export type ComicalbumsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comicalbums to aggregate.
     */
    where?: comicalbumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicalbums to fetch.
     */
    orderBy?: comicalbumsOrderByWithRelationInput | comicalbumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comicalbumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicalbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicalbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comicalbums
    **/
    _count?: true | ComicalbumsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComicalbumsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComicalbumsMaxAggregateInputType
  }

  export type GetComicalbumsAggregateType<T extends ComicalbumsAggregateArgs> = {
        [P in keyof T & keyof AggregateComicalbums]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComicalbums[P]>
      : GetScalarType<T[P], AggregateComicalbums[P]>
  }




  export type comicalbumsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comicalbumsWhereInput
    orderBy?: comicalbumsOrderByWithAggregationInput | comicalbumsOrderByWithAggregationInput[]
    by: ComicalbumsScalarFieldEnum[] | ComicalbumsScalarFieldEnum
    having?: comicalbumsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComicalbumsCountAggregateInputType | true
    _min?: ComicalbumsMinAggregateInputType
    _max?: ComicalbumsMaxAggregateInputType
  }

  export type ComicalbumsGroupByOutputType = {
    id: string
    albumName: string
    comicList: string[]
    _count: ComicalbumsCountAggregateOutputType | null
    _min: ComicalbumsMinAggregateOutputType | null
    _max: ComicalbumsMaxAggregateOutputType | null
  }

  type GetComicalbumsGroupByPayload<T extends comicalbumsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComicalbumsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComicalbumsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComicalbumsGroupByOutputType[P]>
            : GetScalarType<T[P], ComicalbumsGroupByOutputType[P]>
        }
      >
    >


  export type comicalbumsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    albumName?: boolean
    comicList?: boolean
  }, ExtArgs["result"]["comicalbums"]>

  export type comicalbumsSelectScalar = {
    id?: boolean
    albumName?: boolean
    comicList?: boolean
  }



  export type $comicalbumsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comicalbums"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      albumName: string
      comicList: string[]
    }, ExtArgs["result"]["comicalbums"]>
    composites: {}
  }


  type comicalbumsGetPayload<S extends boolean | null | undefined | comicalbumsDefaultArgs> = $Result.GetResult<Prisma.$comicalbumsPayload, S>

  type comicalbumsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comicalbumsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComicalbumsCountAggregateInputType | true
    }

  export interface comicalbumsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comicalbums'], meta: { name: 'comicalbums' } }
    /**
     * Find zero or one Comicalbums that matches the filter.
     * @param {comicalbumsFindUniqueArgs} args - Arguments to find a Comicalbums
     * @example
     * // Get one Comicalbums
     * const comicalbums = await prisma.comicalbums.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comicalbumsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsFindUniqueArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comicalbums that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comicalbumsFindUniqueOrThrowArgs} args - Arguments to find a Comicalbums
     * @example
     * // Get one Comicalbums
     * const comicalbums = await prisma.comicalbums.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comicalbumsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comicalbums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsFindFirstArgs} args - Arguments to find a Comicalbums
     * @example
     * // Get one Comicalbums
     * const comicalbums = await prisma.comicalbums.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comicalbumsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsFindFirstArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comicalbums that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsFindFirstOrThrowArgs} args - Arguments to find a Comicalbums
     * @example
     * // Get one Comicalbums
     * const comicalbums = await prisma.comicalbums.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comicalbumsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comicalbums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comicalbums
     * const comicalbums = await prisma.comicalbums.findMany()
     * 
     * // Get first 10 Comicalbums
     * const comicalbums = await prisma.comicalbums.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comicalbumsWithIdOnly = await prisma.comicalbums.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends comicalbumsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comicalbums.
     * @param {comicalbumsCreateArgs} args - Arguments to create a Comicalbums.
     * @example
     * // Create one Comicalbums
     * const Comicalbums = await prisma.comicalbums.create({
     *   data: {
     *     // ... data to create a Comicalbums
     *   }
     * })
     * 
    **/
    create<T extends comicalbumsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsCreateArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comicalbums.
     *     @param {comicalbumsCreateManyArgs} args - Arguments to create many Comicalbums.
     *     @example
     *     // Create many Comicalbums
     *     const comicalbums = await prisma.comicalbums.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comicalbumsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comicalbums.
     * @param {comicalbumsDeleteArgs} args - Arguments to delete one Comicalbums.
     * @example
     * // Delete one Comicalbums
     * const Comicalbums = await prisma.comicalbums.delete({
     *   where: {
     *     // ... filter to delete one Comicalbums
     *   }
     * })
     * 
    **/
    delete<T extends comicalbumsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsDeleteArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comicalbums.
     * @param {comicalbumsUpdateArgs} args - Arguments to update one Comicalbums.
     * @example
     * // Update one Comicalbums
     * const comicalbums = await prisma.comicalbums.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comicalbumsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsUpdateArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comicalbums.
     * @param {comicalbumsDeleteManyArgs} args - Arguments to filter Comicalbums to delete.
     * @example
     * // Delete a few Comicalbums
     * const { count } = await prisma.comicalbums.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comicalbumsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicalbumsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comicalbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comicalbums
     * const comicalbums = await prisma.comicalbums.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comicalbumsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comicalbums.
     * @param {comicalbumsUpsertArgs} args - Arguments to update or create a Comicalbums.
     * @example
     * // Update or create a Comicalbums
     * const comicalbums = await prisma.comicalbums.upsert({
     *   create: {
     *     // ... data to create a Comicalbums
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comicalbums we want to update
     *   }
     * })
    **/
    upsert<T extends comicalbumsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comicalbumsUpsertArgs<ExtArgs>>
    ): Prisma__comicalbumsClient<$Result.GetResult<Prisma.$comicalbumsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Comicalbums that matches the filter.
     * @param {comicalbumsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comicalbums = await prisma.comicalbums.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: comicalbumsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comicalbums.
     * @param {comicalbumsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comicalbums = await prisma.comicalbums.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: comicalbumsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Comicalbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsCountArgs} args - Arguments to filter Comicalbums to count.
     * @example
     * // Count the number of Comicalbums
     * const count = await prisma.comicalbums.count({
     *   where: {
     *     // ... the filter for the Comicalbums we want to count
     *   }
     * })
    **/
    count<T extends comicalbumsCountArgs>(
      args?: Subset<T, comicalbumsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComicalbumsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comicalbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicalbumsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComicalbumsAggregateArgs>(args: Subset<T, ComicalbumsAggregateArgs>): Prisma.PrismaPromise<GetComicalbumsAggregateType<T>>

    /**
     * Group by Comicalbums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicalbumsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comicalbumsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comicalbumsGroupByArgs['orderBy'] }
        : { orderBy?: comicalbumsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comicalbumsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComicalbumsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comicalbums model
   */
  readonly fields: comicalbumsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comicalbums.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comicalbumsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the comicalbums model
   */ 
  interface comicalbumsFieldRefs {
    readonly id: FieldRef<"comicalbums", 'String'>
    readonly albumName: FieldRef<"comicalbums", 'String'>
    readonly comicList: FieldRef<"comicalbums", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * comicalbums findUnique
   */
  export type comicalbumsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter, which comicalbums to fetch.
     */
    where: comicalbumsWhereUniqueInput
  }

  /**
   * comicalbums findUniqueOrThrow
   */
  export type comicalbumsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter, which comicalbums to fetch.
     */
    where: comicalbumsWhereUniqueInput
  }

  /**
   * comicalbums findFirst
   */
  export type comicalbumsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter, which comicalbums to fetch.
     */
    where?: comicalbumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicalbums to fetch.
     */
    orderBy?: comicalbumsOrderByWithRelationInput | comicalbumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comicalbums.
     */
    cursor?: comicalbumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicalbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicalbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comicalbums.
     */
    distinct?: ComicalbumsScalarFieldEnum | ComicalbumsScalarFieldEnum[]
  }

  /**
   * comicalbums findFirstOrThrow
   */
  export type comicalbumsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter, which comicalbums to fetch.
     */
    where?: comicalbumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicalbums to fetch.
     */
    orderBy?: comicalbumsOrderByWithRelationInput | comicalbumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comicalbums.
     */
    cursor?: comicalbumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicalbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicalbums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comicalbums.
     */
    distinct?: ComicalbumsScalarFieldEnum | ComicalbumsScalarFieldEnum[]
  }

  /**
   * comicalbums findMany
   */
  export type comicalbumsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter, which comicalbums to fetch.
     */
    where?: comicalbumsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicalbums to fetch.
     */
    orderBy?: comicalbumsOrderByWithRelationInput | comicalbumsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comicalbums.
     */
    cursor?: comicalbumsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicalbums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicalbums.
     */
    skip?: number
    distinct?: ComicalbumsScalarFieldEnum | ComicalbumsScalarFieldEnum[]
  }

  /**
   * comicalbums create
   */
  export type comicalbumsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * The data needed to create a comicalbums.
     */
    data: XOR<comicalbumsCreateInput, comicalbumsUncheckedCreateInput>
  }

  /**
   * comicalbums createMany
   */
  export type comicalbumsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comicalbums.
     */
    data: comicalbumsCreateManyInput | comicalbumsCreateManyInput[]
  }

  /**
   * comicalbums update
   */
  export type comicalbumsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * The data needed to update a comicalbums.
     */
    data: XOR<comicalbumsUpdateInput, comicalbumsUncheckedUpdateInput>
    /**
     * Choose, which comicalbums to update.
     */
    where: comicalbumsWhereUniqueInput
  }

  /**
   * comicalbums updateMany
   */
  export type comicalbumsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comicalbums.
     */
    data: XOR<comicalbumsUpdateManyMutationInput, comicalbumsUncheckedUpdateManyInput>
    /**
     * Filter which comicalbums to update
     */
    where?: comicalbumsWhereInput
  }

  /**
   * comicalbums upsert
   */
  export type comicalbumsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * The filter to search for the comicalbums to update in case it exists.
     */
    where: comicalbumsWhereUniqueInput
    /**
     * In case the comicalbums found by the `where` argument doesn't exist, create a new comicalbums with this data.
     */
    create: XOR<comicalbumsCreateInput, comicalbumsUncheckedCreateInput>
    /**
     * In case the comicalbums was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comicalbumsUpdateInput, comicalbumsUncheckedUpdateInput>
  }

  /**
   * comicalbums delete
   */
  export type comicalbumsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
    /**
     * Filter which comicalbums to delete.
     */
    where: comicalbumsWhereUniqueInput
  }

  /**
   * comicalbums deleteMany
   */
  export type comicalbumsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comicalbums to delete
     */
    where?: comicalbumsWhereInput
  }

  /**
   * comicalbums findRaw
   */
  export type comicalbumsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comicalbums aggregateRaw
   */
  export type comicalbumsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comicalbums without action
   */
  export type comicalbumsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicalbums
     */
    select?: comicalbumsSelect<ExtArgs> | null
  }


  /**
   * Model comicchapters
   */

  export type AggregateComicchapters = {
    _count: ComicchaptersCountAggregateOutputType | null
    _avg: ComicchaptersAvgAggregateOutputType | null
    _sum: ComicchaptersSumAggregateOutputType | null
    _min: ComicchaptersMinAggregateOutputType | null
    _max: ComicchaptersMaxAggregateOutputType | null
  }

  export type ComicchaptersAvgAggregateOutputType = {
    unlockPrice: number | null
    views: number | null
  }

  export type ComicchaptersSumAggregateOutputType = {
    unlockPrice: number | null
    views: number | null
  }

  export type ComicchaptersMinAggregateOutputType = {
    id: string | null
    chapterName: string | null
    coverImage: string | null
    publicTime: Date | null
    unlockPrice: number | null
    views: number | null
  }

  export type ComicchaptersMaxAggregateOutputType = {
    id: string | null
    chapterName: string | null
    coverImage: string | null
    publicTime: Date | null
    unlockPrice: number | null
    views: number | null
  }

  export type ComicchaptersCountAggregateOutputType = {
    id: number
    chapterName: number
    content: number
    coverImage: number
    likes: number
    publicTime: number
    unlockPrice: number
    userUnlocked: number
    views: number
    _all: number
  }


  export type ComicchaptersAvgAggregateInputType = {
    unlockPrice?: true
    views?: true
  }

  export type ComicchaptersSumAggregateInputType = {
    unlockPrice?: true
    views?: true
  }

  export type ComicchaptersMinAggregateInputType = {
    id?: true
    chapterName?: true
    coverImage?: true
    publicTime?: true
    unlockPrice?: true
    views?: true
  }

  export type ComicchaptersMaxAggregateInputType = {
    id?: true
    chapterName?: true
    coverImage?: true
    publicTime?: true
    unlockPrice?: true
    views?: true
  }

  export type ComicchaptersCountAggregateInputType = {
    id?: true
    chapterName?: true
    content?: true
    coverImage?: true
    likes?: true
    publicTime?: true
    unlockPrice?: true
    userUnlocked?: true
    views?: true
    _all?: true
  }

  export type ComicchaptersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comicchapters to aggregate.
     */
    where?: comicchaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicchapters to fetch.
     */
    orderBy?: comicchaptersOrderByWithRelationInput | comicchaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comicchaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicchapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicchapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comicchapters
    **/
    _count?: true | ComicchaptersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComicchaptersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComicchaptersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComicchaptersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComicchaptersMaxAggregateInputType
  }

  export type GetComicchaptersAggregateType<T extends ComicchaptersAggregateArgs> = {
        [P in keyof T & keyof AggregateComicchapters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComicchapters[P]>
      : GetScalarType<T[P], AggregateComicchapters[P]>
  }




  export type comicchaptersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comicchaptersWhereInput
    orderBy?: comicchaptersOrderByWithAggregationInput | comicchaptersOrderByWithAggregationInput[]
    by: ComicchaptersScalarFieldEnum[] | ComicchaptersScalarFieldEnum
    having?: comicchaptersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComicchaptersCountAggregateInputType | true
    _avg?: ComicchaptersAvgAggregateInputType
    _sum?: ComicchaptersSumAggregateInputType
    _min?: ComicchaptersMinAggregateInputType
    _max?: ComicchaptersMaxAggregateInputType
  }

  export type ComicchaptersGroupByOutputType = {
    id: string
    chapterName: string
    content: string[]
    coverImage: string
    likes: JsonValue | null
    publicTime: Date
    unlockPrice: number
    userUnlocked: JsonValue | null
    views: number
    _count: ComicchaptersCountAggregateOutputType | null
    _avg: ComicchaptersAvgAggregateOutputType | null
    _sum: ComicchaptersSumAggregateOutputType | null
    _min: ComicchaptersMinAggregateOutputType | null
    _max: ComicchaptersMaxAggregateOutputType | null
  }

  type GetComicchaptersGroupByPayload<T extends comicchaptersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComicchaptersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComicchaptersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComicchaptersGroupByOutputType[P]>
            : GetScalarType<T[P], ComicchaptersGroupByOutputType[P]>
        }
      >
    >


  export type comicchaptersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterName?: boolean
    comments?: boolean | ComicchaptersCommentsDefaultArgs<ExtArgs>
    content?: boolean
    coverImage?: boolean
    likes?: boolean
    publicTime?: boolean
    unlockPrice?: boolean
    userUnlocked?: boolean
    views?: boolean
  }, ExtArgs["result"]["comicchapters"]>

  export type comicchaptersSelectScalar = {
    id?: boolean
    chapterName?: boolean
    content?: boolean
    coverImage?: boolean
    likes?: boolean
    publicTime?: boolean
    unlockPrice?: boolean
    userUnlocked?: boolean
    views?: boolean
  }


  export type comicchaptersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $comicchaptersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comicchapters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterName: string
      content: string[]
      coverImage: string
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      likes: Prisma.JsonValue | null
      publicTime: Date
      unlockPrice: number
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      userUnlocked: Prisma.JsonValue | null
      views: number
    }, ExtArgs["result"]["comicchapters"]>
    composites: {
      comments: Prisma.$ComicchaptersCommentsPayload[]
    }
  }


  type comicchaptersGetPayload<S extends boolean | null | undefined | comicchaptersDefaultArgs> = $Result.GetResult<Prisma.$comicchaptersPayload, S>

  type comicchaptersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comicchaptersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComicchaptersCountAggregateInputType | true
    }

  export interface comicchaptersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comicchapters'], meta: { name: 'comicchapters' } }
    /**
     * Find zero or one Comicchapters that matches the filter.
     * @param {comicchaptersFindUniqueArgs} args - Arguments to find a Comicchapters
     * @example
     * // Get one Comicchapters
     * const comicchapters = await prisma.comicchapters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comicchaptersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersFindUniqueArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comicchapters that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comicchaptersFindUniqueOrThrowArgs} args - Arguments to find a Comicchapters
     * @example
     * // Get one Comicchapters
     * const comicchapters = await prisma.comicchapters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comicchaptersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comicchapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersFindFirstArgs} args - Arguments to find a Comicchapters
     * @example
     * // Get one Comicchapters
     * const comicchapters = await prisma.comicchapters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comicchaptersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersFindFirstArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comicchapters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersFindFirstOrThrowArgs} args - Arguments to find a Comicchapters
     * @example
     * // Get one Comicchapters
     * const comicchapters = await prisma.comicchapters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comicchaptersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comicchapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comicchapters
     * const comicchapters = await prisma.comicchapters.findMany()
     * 
     * // Get first 10 Comicchapters
     * const comicchapters = await prisma.comicchapters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comicchaptersWithIdOnly = await prisma.comicchapters.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends comicchaptersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comicchapters.
     * @param {comicchaptersCreateArgs} args - Arguments to create a Comicchapters.
     * @example
     * // Create one Comicchapters
     * const Comicchapters = await prisma.comicchapters.create({
     *   data: {
     *     // ... data to create a Comicchapters
     *   }
     * })
     * 
    **/
    create<T extends comicchaptersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersCreateArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comicchapters.
     *     @param {comicchaptersCreateManyArgs} args - Arguments to create many Comicchapters.
     *     @example
     *     // Create many Comicchapters
     *     const comicchapters = await prisma.comicchapters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comicchaptersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comicchapters.
     * @param {comicchaptersDeleteArgs} args - Arguments to delete one Comicchapters.
     * @example
     * // Delete one Comicchapters
     * const Comicchapters = await prisma.comicchapters.delete({
     *   where: {
     *     // ... filter to delete one Comicchapters
     *   }
     * })
     * 
    **/
    delete<T extends comicchaptersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersDeleteArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comicchapters.
     * @param {comicchaptersUpdateArgs} args - Arguments to update one Comicchapters.
     * @example
     * // Update one Comicchapters
     * const comicchapters = await prisma.comicchapters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comicchaptersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersUpdateArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comicchapters.
     * @param {comicchaptersDeleteManyArgs} args - Arguments to filter Comicchapters to delete.
     * @example
     * // Delete a few Comicchapters
     * const { count } = await prisma.comicchapters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comicchaptersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicchaptersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comicchapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comicchapters
     * const comicchapters = await prisma.comicchapters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comicchaptersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comicchapters.
     * @param {comicchaptersUpsertArgs} args - Arguments to update or create a Comicchapters.
     * @example
     * // Update or create a Comicchapters
     * const comicchapters = await prisma.comicchapters.upsert({
     *   create: {
     *     // ... data to create a Comicchapters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comicchapters we want to update
     *   }
     * })
    **/
    upsert<T extends comicchaptersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comicchaptersUpsertArgs<ExtArgs>>
    ): Prisma__comicchaptersClient<$Result.GetResult<Prisma.$comicchaptersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Comicchapters that matches the filter.
     * @param {comicchaptersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comicchapters = await prisma.comicchapters.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: comicchaptersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comicchapters.
     * @param {comicchaptersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comicchapters = await prisma.comicchapters.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: comicchaptersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Comicchapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersCountArgs} args - Arguments to filter Comicchapters to count.
     * @example
     * // Count the number of Comicchapters
     * const count = await prisma.comicchapters.count({
     *   where: {
     *     // ... the filter for the Comicchapters we want to count
     *   }
     * })
    **/
    count<T extends comicchaptersCountArgs>(
      args?: Subset<T, comicchaptersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComicchaptersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comicchapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicchaptersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComicchaptersAggregateArgs>(args: Subset<T, ComicchaptersAggregateArgs>): Prisma.PrismaPromise<GetComicchaptersAggregateType<T>>

    /**
     * Group by Comicchapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicchaptersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comicchaptersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comicchaptersGroupByArgs['orderBy'] }
        : { orderBy?: comicchaptersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comicchaptersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComicchaptersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comicchapters model
   */
  readonly fields: comicchaptersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comicchapters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comicchaptersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the comicchapters model
   */ 
  interface comicchaptersFieldRefs {
    readonly id: FieldRef<"comicchapters", 'String'>
    readonly chapterName: FieldRef<"comicchapters", 'String'>
    readonly content: FieldRef<"comicchapters", 'String[]'>
    readonly coverImage: FieldRef<"comicchapters", 'String'>
    readonly likes: FieldRef<"comicchapters", 'Json'>
    readonly publicTime: FieldRef<"comicchapters", 'DateTime'>
    readonly unlockPrice: FieldRef<"comicchapters", 'Int'>
    readonly userUnlocked: FieldRef<"comicchapters", 'Json'>
    readonly views: FieldRef<"comicchapters", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * comicchapters findUnique
   */
  export type comicchaptersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter, which comicchapters to fetch.
     */
    where: comicchaptersWhereUniqueInput
  }

  /**
   * comicchapters findUniqueOrThrow
   */
  export type comicchaptersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter, which comicchapters to fetch.
     */
    where: comicchaptersWhereUniqueInput
  }

  /**
   * comicchapters findFirst
   */
  export type comicchaptersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter, which comicchapters to fetch.
     */
    where?: comicchaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicchapters to fetch.
     */
    orderBy?: comicchaptersOrderByWithRelationInput | comicchaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comicchapters.
     */
    cursor?: comicchaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicchapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicchapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comicchapters.
     */
    distinct?: ComicchaptersScalarFieldEnum | ComicchaptersScalarFieldEnum[]
  }

  /**
   * comicchapters findFirstOrThrow
   */
  export type comicchaptersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter, which comicchapters to fetch.
     */
    where?: comicchaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicchapters to fetch.
     */
    orderBy?: comicchaptersOrderByWithRelationInput | comicchaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comicchapters.
     */
    cursor?: comicchaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicchapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicchapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comicchapters.
     */
    distinct?: ComicchaptersScalarFieldEnum | ComicchaptersScalarFieldEnum[]
  }

  /**
   * comicchapters findMany
   */
  export type comicchaptersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter, which comicchapters to fetch.
     */
    where?: comicchaptersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comicchapters to fetch.
     */
    orderBy?: comicchaptersOrderByWithRelationInput | comicchaptersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comicchapters.
     */
    cursor?: comicchaptersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comicchapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comicchapters.
     */
    skip?: number
    distinct?: ComicchaptersScalarFieldEnum | ComicchaptersScalarFieldEnum[]
  }

  /**
   * comicchapters create
   */
  export type comicchaptersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * The data needed to create a comicchapters.
     */
    data: XOR<comicchaptersCreateInput, comicchaptersUncheckedCreateInput>
  }

  /**
   * comicchapters createMany
   */
  export type comicchaptersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comicchapters.
     */
    data: comicchaptersCreateManyInput | comicchaptersCreateManyInput[]
  }

  /**
   * comicchapters update
   */
  export type comicchaptersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * The data needed to update a comicchapters.
     */
    data: XOR<comicchaptersUpdateInput, comicchaptersUncheckedUpdateInput>
    /**
     * Choose, which comicchapters to update.
     */
    where: comicchaptersWhereUniqueInput
  }

  /**
   * comicchapters updateMany
   */
  export type comicchaptersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comicchapters.
     */
    data: XOR<comicchaptersUpdateManyMutationInput, comicchaptersUncheckedUpdateManyInput>
    /**
     * Filter which comicchapters to update
     */
    where?: comicchaptersWhereInput
  }

  /**
   * comicchapters upsert
   */
  export type comicchaptersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * The filter to search for the comicchapters to update in case it exists.
     */
    where: comicchaptersWhereUniqueInput
    /**
     * In case the comicchapters found by the `where` argument doesn't exist, create a new comicchapters with this data.
     */
    create: XOR<comicchaptersCreateInput, comicchaptersUncheckedCreateInput>
    /**
     * In case the comicchapters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comicchaptersUpdateInput, comicchaptersUncheckedUpdateInput>
  }

  /**
   * comicchapters delete
   */
  export type comicchaptersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
    /**
     * Filter which comicchapters to delete.
     */
    where: comicchaptersWhereUniqueInput
  }

  /**
   * comicchapters deleteMany
   */
  export type comicchaptersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comicchapters to delete
     */
    where?: comicchaptersWhereInput
  }

  /**
   * comicchapters findRaw
   */
  export type comicchaptersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comicchapters aggregateRaw
   */
  export type comicchaptersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comicchapters without action
   */
  export type comicchaptersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comicchapters
     */
    select?: comicchaptersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comicchaptersInclude<ExtArgs> | null
  }


  /**
   * Model comics
   */

  export type AggregateComics = {
    _count: ComicsCountAggregateOutputType | null
    _min: ComicsMinAggregateOutputType | null
    _max: ComicsMaxAggregateOutputType | null
  }

  export type ComicsMinAggregateOutputType = {
    id: string | null
    ageFor: string | null
    artist: string | null
    author: string | null
    comicName: string | null
    coverImage: string | null
    description: string | null
    landspaceImage: string | null
    newChapterTime: string | null
    publisher: string | null
  }

  export type ComicsMaxAggregateOutputType = {
    id: string | null
    ageFor: string | null
    artist: string | null
    author: string | null
    comicName: string | null
    coverImage: string | null
    description: string | null
    landspaceImage: string | null
    newChapterTime: string | null
    publisher: string | null
  }

  export type ComicsCountAggregateOutputType = {
    id: number
    ageFor: number
    artist: number
    author: number
    chapterList: number
    comicName: number
    coverImage: number
    description: number
    genres: number
    landspaceImage: number
    newChapterTime: number
    publisher: number
    _all: number
  }


  export type ComicsMinAggregateInputType = {
    id?: true
    ageFor?: true
    artist?: true
    author?: true
    comicName?: true
    coverImage?: true
    description?: true
    landspaceImage?: true
    newChapterTime?: true
    publisher?: true
  }

  export type ComicsMaxAggregateInputType = {
    id?: true
    ageFor?: true
    artist?: true
    author?: true
    comicName?: true
    coverImage?: true
    description?: true
    landspaceImage?: true
    newChapterTime?: true
    publisher?: true
  }

  export type ComicsCountAggregateInputType = {
    id?: true
    ageFor?: true
    artist?: true
    author?: true
    chapterList?: true
    comicName?: true
    coverImage?: true
    description?: true
    genres?: true
    landspaceImage?: true
    newChapterTime?: true
    publisher?: true
    _all?: true
  }

  export type ComicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comics to aggregate.
     */
    where?: comicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comics to fetch.
     */
    orderBy?: comicsOrderByWithRelationInput | comicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comics
    **/
    _count?: true | ComicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComicsMaxAggregateInputType
  }

  export type GetComicsAggregateType<T extends ComicsAggregateArgs> = {
        [P in keyof T & keyof AggregateComics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComics[P]>
      : GetScalarType<T[P], AggregateComics[P]>
  }




  export type comicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comicsWhereInput
    orderBy?: comicsOrderByWithAggregationInput | comicsOrderByWithAggregationInput[]
    by: ComicsScalarFieldEnum[] | ComicsScalarFieldEnum
    having?: comicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComicsCountAggregateInputType | true
    _min?: ComicsMinAggregateInputType
    _max?: ComicsMaxAggregateInputType
  }

  export type ComicsGroupByOutputType = {
    id: string
    ageFor: string
    artist: string
    author: string
    chapterList: string[]
    comicName: string
    coverImage: string
    description: string
    genres: string[]
    landspaceImage: string
    newChapterTime: string
    publisher: string
    _count: ComicsCountAggregateOutputType | null
    _min: ComicsMinAggregateOutputType | null
    _max: ComicsMaxAggregateOutputType | null
  }

  type GetComicsGroupByPayload<T extends comicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComicsGroupByOutputType[P]>
            : GetScalarType<T[P], ComicsGroupByOutputType[P]>
        }
      >
    >


  export type comicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ageFor?: boolean
    artist?: boolean
    author?: boolean
    chapterList?: boolean
    comicName?: boolean
    coverImage?: boolean
    description?: boolean
    genres?: boolean
    landspaceImage?: boolean
    newChapterTime?: boolean
    publisher?: boolean
  }, ExtArgs["result"]["comics"]>

  export type comicsSelectScalar = {
    id?: boolean
    ageFor?: boolean
    artist?: boolean
    author?: boolean
    chapterList?: boolean
    comicName?: boolean
    coverImage?: boolean
    description?: boolean
    genres?: boolean
    landspaceImage?: boolean
    newChapterTime?: boolean
    publisher?: boolean
  }



  export type $comicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ageFor: string
      artist: string
      author: string
      chapterList: string[]
      comicName: string
      coverImage: string
      description: string
      genres: string[]
      landspaceImage: string
      newChapterTime: string
      publisher: string
    }, ExtArgs["result"]["comics"]>
    composites: {}
  }


  type comicsGetPayload<S extends boolean | null | undefined | comicsDefaultArgs> = $Result.GetResult<Prisma.$comicsPayload, S>

  type comicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comicsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComicsCountAggregateInputType | true
    }

  export interface comicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comics'], meta: { name: 'comics' } }
    /**
     * Find zero or one Comics that matches the filter.
     * @param {comicsFindUniqueArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comicsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, comicsFindUniqueArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comicsFindUniqueOrThrowArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comicsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsFindFirstArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comicsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsFindFirstArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsFindFirstOrThrowArgs} args - Arguments to find a Comics
     * @example
     * // Get one Comics
     * const comics = await prisma.comics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comicsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comics
     * const comics = await prisma.comics.findMany()
     * 
     * // Get first 10 Comics
     * const comics = await prisma.comics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comicsWithIdOnly = await prisma.comics.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends comicsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comics.
     * @param {comicsCreateArgs} args - Arguments to create a Comics.
     * @example
     * // Create one Comics
     * const Comics = await prisma.comics.create({
     *   data: {
     *     // ... data to create a Comics
     *   }
     * })
     * 
    **/
    create<T extends comicsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comicsCreateArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comics.
     *     @param {comicsCreateManyArgs} args - Arguments to create many Comics.
     *     @example
     *     // Create many Comics
     *     const comics = await prisma.comics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comicsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comics.
     * @param {comicsDeleteArgs} args - Arguments to delete one Comics.
     * @example
     * // Delete one Comics
     * const Comics = await prisma.comics.delete({
     *   where: {
     *     // ... filter to delete one Comics
     *   }
     * })
     * 
    **/
    delete<T extends comicsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comicsDeleteArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comics.
     * @param {comicsUpdateArgs} args - Arguments to update one Comics.
     * @example
     * // Update one Comics
     * const comics = await prisma.comics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comicsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comicsUpdateArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comics.
     * @param {comicsDeleteManyArgs} args - Arguments to filter Comics to delete.
     * @example
     * // Delete a few Comics
     * const { count } = await prisma.comics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comicsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comicsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comics
     * const comics = await prisma.comics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comicsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comicsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comics.
     * @param {comicsUpsertArgs} args - Arguments to update or create a Comics.
     * @example
     * // Update or create a Comics
     * const comics = await prisma.comics.upsert({
     *   create: {
     *     // ... data to create a Comics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comics we want to update
     *   }
     * })
    **/
    upsert<T extends comicsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comicsUpsertArgs<ExtArgs>>
    ): Prisma__comicsClient<$Result.GetResult<Prisma.$comicsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Comics that matches the filter.
     * @param {comicsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const comics = await prisma.comics.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: comicsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Comics.
     * @param {comicsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const comics = await prisma.comics.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: comicsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsCountArgs} args - Arguments to filter Comics to count.
     * @example
     * // Count the number of Comics
     * const count = await prisma.comics.count({
     *   where: {
     *     // ... the filter for the Comics we want to count
     *   }
     * })
    **/
    count<T extends comicsCountArgs>(
      args?: Subset<T, comicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComicsAggregateArgs>(args: Subset<T, ComicsAggregateArgs>): Prisma.PrismaPromise<GetComicsAggregateType<T>>

    /**
     * Group by Comics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comicsGroupByArgs['orderBy'] }
        : { orderBy?: comicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comics model
   */
  readonly fields: comicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the comics model
   */ 
  interface comicsFieldRefs {
    readonly id: FieldRef<"comics", 'String'>
    readonly ageFor: FieldRef<"comics", 'String'>
    readonly artist: FieldRef<"comics", 'String'>
    readonly author: FieldRef<"comics", 'String'>
    readonly chapterList: FieldRef<"comics", 'String[]'>
    readonly comicName: FieldRef<"comics", 'String'>
    readonly coverImage: FieldRef<"comics", 'String'>
    readonly description: FieldRef<"comics", 'String'>
    readonly genres: FieldRef<"comics", 'String[]'>
    readonly landspaceImage: FieldRef<"comics", 'String'>
    readonly newChapterTime: FieldRef<"comics", 'String'>
    readonly publisher: FieldRef<"comics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comics findUnique
   */
  export type comicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter, which comics to fetch.
     */
    where: comicsWhereUniqueInput
  }

  /**
   * comics findUniqueOrThrow
   */
  export type comicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter, which comics to fetch.
     */
    where: comicsWhereUniqueInput
  }

  /**
   * comics findFirst
   */
  export type comicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter, which comics to fetch.
     */
    where?: comicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comics to fetch.
     */
    orderBy?: comicsOrderByWithRelationInput | comicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comics.
     */
    cursor?: comicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comics.
     */
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * comics findFirstOrThrow
   */
  export type comicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter, which comics to fetch.
     */
    where?: comicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comics to fetch.
     */
    orderBy?: comicsOrderByWithRelationInput | comicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comics.
     */
    cursor?: comicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comics.
     */
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * comics findMany
   */
  export type comicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter, which comics to fetch.
     */
    where?: comicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comics to fetch.
     */
    orderBy?: comicsOrderByWithRelationInput | comicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comics.
     */
    cursor?: comicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comics.
     */
    skip?: number
    distinct?: ComicsScalarFieldEnum | ComicsScalarFieldEnum[]
  }

  /**
   * comics create
   */
  export type comicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * The data needed to create a comics.
     */
    data: XOR<comicsCreateInput, comicsUncheckedCreateInput>
  }

  /**
   * comics createMany
   */
  export type comicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comics.
     */
    data: comicsCreateManyInput | comicsCreateManyInput[]
  }

  /**
   * comics update
   */
  export type comicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * The data needed to update a comics.
     */
    data: XOR<comicsUpdateInput, comicsUncheckedUpdateInput>
    /**
     * Choose, which comics to update.
     */
    where: comicsWhereUniqueInput
  }

  /**
   * comics updateMany
   */
  export type comicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comics.
     */
    data: XOR<comicsUpdateManyMutationInput, comicsUncheckedUpdateManyInput>
    /**
     * Filter which comics to update
     */
    where?: comicsWhereInput
  }

  /**
   * comics upsert
   */
  export type comicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * The filter to search for the comics to update in case it exists.
     */
    where: comicsWhereUniqueInput
    /**
     * In case the comics found by the `where` argument doesn't exist, create a new comics with this data.
     */
    create: XOR<comicsCreateInput, comicsUncheckedCreateInput>
    /**
     * In case the comics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comicsUpdateInput, comicsUncheckedUpdateInput>
  }

  /**
   * comics delete
   */
  export type comicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
    /**
     * Filter which comics to delete.
     */
    where: comicsWhereUniqueInput
  }

  /**
   * comics deleteMany
   */
  export type comicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comics to delete
     */
    where?: comicsWhereInput
  }

  /**
   * comics findRaw
   */
  export type comicsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comics aggregateRaw
   */
  export type comicsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * comics without action
   */
  export type comicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comics
     */
    select?: comicsSelect<ExtArgs> | null
  }


  /**
   * Model genres
   */

  export type AggregateGenres = {
    _count: GenresCountAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  export type GenresMinAggregateOutputType = {
    id: string | null
    genreName: string | null
  }

  export type GenresMaxAggregateOutputType = {
    id: string | null
    genreName: string | null
  }

  export type GenresCountAggregateOutputType = {
    id: number
    genreName: number
    _all: number
  }


  export type GenresMinAggregateInputType = {
    id?: true
    genreName?: true
  }

  export type GenresMaxAggregateInputType = {
    id?: true
    genreName?: true
  }

  export type GenresCountAggregateInputType = {
    id?: true
    genreName?: true
    _all?: true
  }

  export type GenresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which genres to aggregate.
     */
    where?: genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genresOrderByWithRelationInput | genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genres
    **/
    _count?: true | GenresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenresMaxAggregateInputType
  }

  export type GetGenresAggregateType<T extends GenresAggregateArgs> = {
        [P in keyof T & keyof AggregateGenres]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenres[P]>
      : GetScalarType<T[P], AggregateGenres[P]>
  }




  export type genresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: genresWhereInput
    orderBy?: genresOrderByWithAggregationInput | genresOrderByWithAggregationInput[]
    by: GenresScalarFieldEnum[] | GenresScalarFieldEnum
    having?: genresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenresCountAggregateInputType | true
    _min?: GenresMinAggregateInputType
    _max?: GenresMaxAggregateInputType
  }

  export type GenresGroupByOutputType = {
    id: string
    genreName: string
    _count: GenresCountAggregateOutputType | null
    _min: GenresMinAggregateOutputType | null
    _max: GenresMaxAggregateOutputType | null
  }

  type GetGenresGroupByPayload<T extends genresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenresGroupByOutputType[P]>
            : GetScalarType<T[P], GenresGroupByOutputType[P]>
        }
      >
    >


  export type genresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    genreName?: boolean
  }, ExtArgs["result"]["genres"]>

  export type genresSelectScalar = {
    id?: boolean
    genreName?: boolean
  }



  export type $genresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "genres"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      genreName: string
    }, ExtArgs["result"]["genres"]>
    composites: {}
  }


  type genresGetPayload<S extends boolean | null | undefined | genresDefaultArgs> = $Result.GetResult<Prisma.$genresPayload, S>

  type genresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<genresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GenresCountAggregateInputType | true
    }

  export interface genresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['genres'], meta: { name: 'genres' } }
    /**
     * Find zero or one Genres that matches the filter.
     * @param {genresFindUniqueArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends genresFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, genresFindUniqueArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Genres that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {genresFindUniqueOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends genresFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, genresFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresFindFirstArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends genresFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, genresFindFirstArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Genres that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresFindFirstOrThrowArgs} args - Arguments to find a Genres
     * @example
     * // Get one Genres
     * const genres = await prisma.genres.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends genresFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, genresFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genres.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genres.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genresWithIdOnly = await prisma.genres.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends genresFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, genresFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Genres.
     * @param {genresCreateArgs} args - Arguments to create a Genres.
     * @example
     * // Create one Genres
     * const Genres = await prisma.genres.create({
     *   data: {
     *     // ... data to create a Genres
     *   }
     * })
     * 
    **/
    create<T extends genresCreateArgs<ExtArgs>>(
      args: SelectSubset<T, genresCreateArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Genres.
     *     @param {genresCreateManyArgs} args - Arguments to create many Genres.
     *     @example
     *     // Create many Genres
     *     const genres = await prisma.genres.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends genresCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, genresCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Genres.
     * @param {genresDeleteArgs} args - Arguments to delete one Genres.
     * @example
     * // Delete one Genres
     * const Genres = await prisma.genres.delete({
     *   where: {
     *     // ... filter to delete one Genres
     *   }
     * })
     * 
    **/
    delete<T extends genresDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, genresDeleteArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Genres.
     * @param {genresUpdateArgs} args - Arguments to update one Genres.
     * @example
     * // Update one Genres
     * const genres = await prisma.genres.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends genresUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, genresUpdateArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Genres.
     * @param {genresDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genres.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends genresDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, genresDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genres = await prisma.genres.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends genresUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, genresUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Genres.
     * @param {genresUpsertArgs} args - Arguments to update or create a Genres.
     * @example
     * // Update or create a Genres
     * const genres = await prisma.genres.upsert({
     *   create: {
     *     // ... data to create a Genres
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genres we want to update
     *   }
     * })
    **/
    upsert<T extends genresUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, genresUpsertArgs<ExtArgs>>
    ): Prisma__genresClient<$Result.GetResult<Prisma.$genresPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Genres that matches the filter.
     * @param {genresFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const genres = await prisma.genres.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: genresFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Genres.
     * @param {genresAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const genres = await prisma.genres.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: genresAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genres.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends genresCountArgs>(
      args?: Subset<T, genresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenresAggregateArgs>(args: Subset<T, GenresAggregateArgs>): Prisma.PrismaPromise<GetGenresAggregateType<T>>

    /**
     * Group by Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends genresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: genresGroupByArgs['orderBy'] }
        : { orderBy?: genresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, genresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the genres model
   */
  readonly fields: genresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for genres.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__genresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the genres model
   */ 
  interface genresFieldRefs {
    readonly id: FieldRef<"genres", 'String'>
    readonly genreName: FieldRef<"genres", 'String'>
  }
    

  // Custom InputTypes
  /**
   * genres findUnique
   */
  export type genresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where: genresWhereUniqueInput
  }

  /**
   * genres findUniqueOrThrow
   */
  export type genresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where: genresWhereUniqueInput
  }

  /**
   * genres findFirst
   */
  export type genresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where?: genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genresOrderByWithRelationInput | genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genres.
     */
    cursor?: genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * genres findFirstOrThrow
   */
  export type genresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where?: genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genresOrderByWithRelationInput | genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genres.
     */
    cursor?: genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genres.
     */
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * genres findMany
   */
  export type genresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter, which genres to fetch.
     */
    where?: genresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genres to fetch.
     */
    orderBy?: genresOrderByWithRelationInput | genresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genres.
     */
    cursor?: genresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genres.
     */
    skip?: number
    distinct?: GenresScalarFieldEnum | GenresScalarFieldEnum[]
  }

  /**
   * genres create
   */
  export type genresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * The data needed to create a genres.
     */
    data: XOR<genresCreateInput, genresUncheckedCreateInput>
  }

  /**
   * genres createMany
   */
  export type genresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many genres.
     */
    data: genresCreateManyInput | genresCreateManyInput[]
  }

  /**
   * genres update
   */
  export type genresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * The data needed to update a genres.
     */
    data: XOR<genresUpdateInput, genresUncheckedUpdateInput>
    /**
     * Choose, which genres to update.
     */
    where: genresWhereUniqueInput
  }

  /**
   * genres updateMany
   */
  export type genresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update genres.
     */
    data: XOR<genresUpdateManyMutationInput, genresUncheckedUpdateManyInput>
    /**
     * Filter which genres to update
     */
    where?: genresWhereInput
  }

  /**
   * genres upsert
   */
  export type genresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * The filter to search for the genres to update in case it exists.
     */
    where: genresWhereUniqueInput
    /**
     * In case the genres found by the `where` argument doesn't exist, create a new genres with this data.
     */
    create: XOR<genresCreateInput, genresUncheckedCreateInput>
    /**
     * In case the genres was found with the provided `where` argument, update it with this data.
     */
    update: XOR<genresUpdateInput, genresUncheckedUpdateInput>
  }

  /**
   * genres delete
   */
  export type genresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
    /**
     * Filter which genres to delete.
     */
    where: genresWhereUniqueInput
  }

  /**
   * genres deleteMany
   */
  export type genresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which genres to delete
     */
    where?: genresWhereInput
  }

  /**
   * genres findRaw
   */
  export type genresFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * genres aggregateRaw
   */
  export type genresAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * genres without action
   */
  export type genresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the genres
     */
    select?: genresSelect<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    v: number | null
    coinPoint: number | null
  }

  export type UsersSumAggregateOutputType = {
    v: number | null
    coinPoint: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    v: number | null
    avatar: string | null
    coinPoint: number | null
    phone: string | null
    userName: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    v: number | null
    avatar: string | null
    coinPoint: number | null
    phone: string | null
    userName: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    v: number
    avatar: number
    coinPoint: number
    paymentHistories: number
    phone: number
    userName: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    v?: true
    coinPoint?: true
  }

  export type UsersSumAggregateInputType = {
    v?: true
    coinPoint?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    v?: true
    avatar?: true
    coinPoint?: true
    phone?: true
    userName?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    v?: true
    avatar?: true
    coinPoint?: true
    phone?: true
    userName?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    v?: true
    avatar?: true
    coinPoint?: true
    paymentHistories?: true
    phone?: true
    userName?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    v: number | null
    avatar: string | null
    coinPoint: number | null
    paymentHistories: JsonValue | null
    phone: string | null
    userName: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    v?: boolean
    authentication?: boolean | UsersAuthenticationDefaultArgs<ExtArgs>
    avatar?: boolean
    bookmarkList?: boolean | UsersBookmarkListDefaultArgs<ExtArgs>
    coinPoint?: boolean
    histories?: boolean | UsersHistoriesDefaultArgs<ExtArgs>
    paymentHistories?: boolean
    phone?: boolean
    userName?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    v?: boolean
    avatar?: boolean
    coinPoint?: boolean
    paymentHistories?: boolean
    phone?: boolean
    userName?: boolean
  }


  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      v: number | null
      avatar: string | null
      coinPoint: number | null
      /**
       * Could not determine type: the field only had null or empty values in the sample set.
       */
      paymentHistories: Prisma.JsonValue | null
      phone: string | null
      userName: string | null
    }, ExtArgs["result"]["users"]>
    composites: {
      authentication: Prisma.$UsersAuthenticationPayload | null
      bookmarkList: Prisma.$UsersBookmarkListPayload
      histories: Prisma.$UsersHistoriesPayload
    }
  }


  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: usersFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: usersAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly v: FieldRef<"users", 'Int'>
    readonly avatar: FieldRef<"users", 'String'>
    readonly coinPoint: FieldRef<"users", 'Int'>
    readonly paymentHistories: FieldRef<"users", 'Json'>
    readonly phone: FieldRef<"users", 'String'>
    readonly userName: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const AnimeepisodesScalarFieldEnum: {
    id: 'id',
    adLink: 'adLink',
    advertising: 'advertising',
    content: 'content',
    coverImage: 'coverImage',
    episodeName: 'episodeName',
    likes: 'likes',
    publicTime: 'publicTime',
    totalTime: 'totalTime',
    views: 'views'
  };

  export type AnimeepisodesScalarFieldEnum = (typeof AnimeepisodesScalarFieldEnum)[keyof typeof AnimeepisodesScalarFieldEnum]


  export const AnimesScalarFieldEnum: {
    id: 'id',
    ageFor: 'ageFor',
    coverImage: 'coverImage',
    description: 'description',
    episodes: 'episodes',
    genres: 'genres',
    landspaceImage: 'landspaceImage',
    movieName: 'movieName',
    publishTime: 'publishTime',
    publisher: 'publisher'
  };

  export type AnimesScalarFieldEnum = (typeof AnimesScalarFieldEnum)[keyof typeof AnimesScalarFieldEnum]


  export const BannersScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type BannersScalarFieldEnum = (typeof BannersScalarFieldEnum)[keyof typeof BannersScalarFieldEnum]


  export const ComicalbumsScalarFieldEnum: {
    id: 'id',
    albumName: 'albumName',
    comicList: 'comicList'
  };

  export type ComicalbumsScalarFieldEnum = (typeof ComicalbumsScalarFieldEnum)[keyof typeof ComicalbumsScalarFieldEnum]


  export const ComicchaptersScalarFieldEnum: {
    id: 'id',
    chapterName: 'chapterName',
    content: 'content',
    coverImage: 'coverImage',
    likes: 'likes',
    publicTime: 'publicTime',
    unlockPrice: 'unlockPrice',
    userUnlocked: 'userUnlocked',
    views: 'views'
  };

  export type ComicchaptersScalarFieldEnum = (typeof ComicchaptersScalarFieldEnum)[keyof typeof ComicchaptersScalarFieldEnum]


  export const ComicsScalarFieldEnum: {
    id: 'id',
    ageFor: 'ageFor',
    artist: 'artist',
    author: 'author',
    chapterList: 'chapterList',
    comicName: 'comicName',
    coverImage: 'coverImage',
    description: 'description',
    genres: 'genres',
    landspaceImage: 'landspaceImage',
    newChapterTime: 'newChapterTime',
    publisher: 'publisher'
  };

  export type ComicsScalarFieldEnum = (typeof ComicsScalarFieldEnum)[keyof typeof ComicsScalarFieldEnum]


  export const GenresScalarFieldEnum: {
    id: 'id',
    genreName: 'genreName'
  };

  export type GenresScalarFieldEnum = (typeof GenresScalarFieldEnum)[keyof typeof GenresScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    v: 'v',
    avatar: 'avatar',
    coinPoint: 'coinPoint',
    paymentHistories: 'paymentHistories',
    phone: 'phone',
    userName: 'userName'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type animeepisodesWhereInput = {
    AND?: animeepisodesWhereInput | animeepisodesWhereInput[]
    OR?: animeepisodesWhereInput[]
    NOT?: animeepisodesWhereInput | animeepisodesWhereInput[]
    id?: StringFilter<"animeepisodes"> | string
    adLink?: StringFilter<"animeepisodes"> | string
    advertising?: StringFilter<"animeepisodes"> | string
    comments?: AnimeepisodesCommentsCompositeListFilter | AnimeepisodesCommentsObjectEqualityInput[]
    content?: StringFilter<"animeepisodes"> | string
    coverImage?: StringFilter<"animeepisodes"> | string
    episodeName?: StringFilter<"animeepisodes"> | string
    likes?: JsonNullableFilter<"animeepisodes">
    publicTime?: DateTimeFilter<"animeepisodes"> | Date | string
    totalTime?: IntFilter<"animeepisodes"> | number
    views?: IntFilter<"animeepisodes"> | number
  }

  export type animeepisodesOrderByWithRelationInput = {
    id?: SortOrder
    adLink?: SortOrder
    advertising?: SortOrder
    comments?: AnimeepisodesCommentsOrderByCompositeAggregateInput
    content?: SortOrder
    coverImage?: SortOrder
    episodeName?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type animeepisodesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: animeepisodesWhereInput | animeepisodesWhereInput[]
    OR?: animeepisodesWhereInput[]
    NOT?: animeepisodesWhereInput | animeepisodesWhereInput[]
    adLink?: StringFilter<"animeepisodes"> | string
    advertising?: StringFilter<"animeepisodes"> | string
    comments?: AnimeepisodesCommentsCompositeListFilter | AnimeepisodesCommentsObjectEqualityInput[]
    content?: StringFilter<"animeepisodes"> | string
    coverImage?: StringFilter<"animeepisodes"> | string
    episodeName?: StringFilter<"animeepisodes"> | string
    likes?: JsonNullableFilter<"animeepisodes">
    publicTime?: DateTimeFilter<"animeepisodes"> | Date | string
    totalTime?: IntFilter<"animeepisodes"> | number
    views?: IntFilter<"animeepisodes"> | number
  }, "id">

  export type animeepisodesOrderByWithAggregationInput = {
    id?: SortOrder
    adLink?: SortOrder
    advertising?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    episodeName?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    totalTime?: SortOrder
    views?: SortOrder
    _count?: animeepisodesCountOrderByAggregateInput
    _avg?: animeepisodesAvgOrderByAggregateInput
    _max?: animeepisodesMaxOrderByAggregateInput
    _min?: animeepisodesMinOrderByAggregateInput
    _sum?: animeepisodesSumOrderByAggregateInput
  }

  export type animeepisodesScalarWhereWithAggregatesInput = {
    AND?: animeepisodesScalarWhereWithAggregatesInput | animeepisodesScalarWhereWithAggregatesInput[]
    OR?: animeepisodesScalarWhereWithAggregatesInput[]
    NOT?: animeepisodesScalarWhereWithAggregatesInput | animeepisodesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"animeepisodes"> | string
    adLink?: StringWithAggregatesFilter<"animeepisodes"> | string
    advertising?: StringWithAggregatesFilter<"animeepisodes"> | string
    content?: StringWithAggregatesFilter<"animeepisodes"> | string
    coverImage?: StringWithAggregatesFilter<"animeepisodes"> | string
    episodeName?: StringWithAggregatesFilter<"animeepisodes"> | string
    likes?: JsonNullableWithAggregatesFilter<"animeepisodes">
    publicTime?: DateTimeWithAggregatesFilter<"animeepisodes"> | Date | string
    totalTime?: IntWithAggregatesFilter<"animeepisodes"> | number
    views?: IntWithAggregatesFilter<"animeepisodes"> | number
  }

  export type animesWhereInput = {
    AND?: animesWhereInput | animesWhereInput[]
    OR?: animesWhereInput[]
    NOT?: animesWhereInput | animesWhereInput[]
    id?: StringFilter<"animes"> | string
    ageFor?: StringFilter<"animes"> | string
    coverImage?: StringFilter<"animes"> | string
    description?: StringFilter<"animes"> | string
    episodes?: StringNullableListFilter<"animes">
    genres?: StringNullableListFilter<"animes">
    landspaceImage?: StringFilter<"animes"> | string
    movieName?: StringFilter<"animes"> | string
    publishTime?: StringFilter<"animes"> | string
    publisher?: StringFilter<"animes"> | string
  }

  export type animesOrderByWithRelationInput = {
    id?: SortOrder
    ageFor?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    episodes?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    movieName?: SortOrder
    publishTime?: SortOrder
    publisher?: SortOrder
  }

  export type animesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: animesWhereInput | animesWhereInput[]
    OR?: animesWhereInput[]
    NOT?: animesWhereInput | animesWhereInput[]
    ageFor?: StringFilter<"animes"> | string
    coverImage?: StringFilter<"animes"> | string
    description?: StringFilter<"animes"> | string
    episodes?: StringNullableListFilter<"animes">
    genres?: StringNullableListFilter<"animes">
    landspaceImage?: StringFilter<"animes"> | string
    movieName?: StringFilter<"animes"> | string
    publishTime?: StringFilter<"animes"> | string
    publisher?: StringFilter<"animes"> | string
  }, "id">

  export type animesOrderByWithAggregationInput = {
    id?: SortOrder
    ageFor?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    episodes?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    movieName?: SortOrder
    publishTime?: SortOrder
    publisher?: SortOrder
    _count?: animesCountOrderByAggregateInput
    _max?: animesMaxOrderByAggregateInput
    _min?: animesMinOrderByAggregateInput
  }

  export type animesScalarWhereWithAggregatesInput = {
    AND?: animesScalarWhereWithAggregatesInput | animesScalarWhereWithAggregatesInput[]
    OR?: animesScalarWhereWithAggregatesInput[]
    NOT?: animesScalarWhereWithAggregatesInput | animesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"animes"> | string
    ageFor?: StringWithAggregatesFilter<"animes"> | string
    coverImage?: StringWithAggregatesFilter<"animes"> | string
    description?: StringWithAggregatesFilter<"animes"> | string
    episodes?: StringNullableListFilter<"animes">
    genres?: StringNullableListFilter<"animes">
    landspaceImage?: StringWithAggregatesFilter<"animes"> | string
    movieName?: StringWithAggregatesFilter<"animes"> | string
    publishTime?: StringWithAggregatesFilter<"animes"> | string
    publisher?: StringWithAggregatesFilter<"animes"> | string
  }

  export type bannersWhereInput = {
    AND?: bannersWhereInput | bannersWhereInput[]
    OR?: bannersWhereInput[]
    NOT?: bannersWhereInput | bannersWhereInput[]
    id?: StringFilter<"banners"> | string
    list?: BannersListCompositeListFilter | BannersListObjectEqualityInput[]
    type?: StringFilter<"banners"> | string
  }

  export type bannersOrderByWithRelationInput = {
    id?: SortOrder
    list?: BannersListOrderByCompositeAggregateInput
    type?: SortOrder
  }

  export type bannersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bannersWhereInput | bannersWhereInput[]
    OR?: bannersWhereInput[]
    NOT?: bannersWhereInput | bannersWhereInput[]
    list?: BannersListCompositeListFilter | BannersListObjectEqualityInput[]
    type?: StringFilter<"banners"> | string
  }, "id">

  export type bannersOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: bannersCountOrderByAggregateInput
    _max?: bannersMaxOrderByAggregateInput
    _min?: bannersMinOrderByAggregateInput
  }

  export type bannersScalarWhereWithAggregatesInput = {
    AND?: bannersScalarWhereWithAggregatesInput | bannersScalarWhereWithAggregatesInput[]
    OR?: bannersScalarWhereWithAggregatesInput[]
    NOT?: bannersScalarWhereWithAggregatesInput | bannersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"banners"> | string
    type?: StringWithAggregatesFilter<"banners"> | string
  }

  export type comicalbumsWhereInput = {
    AND?: comicalbumsWhereInput | comicalbumsWhereInput[]
    OR?: comicalbumsWhereInput[]
    NOT?: comicalbumsWhereInput | comicalbumsWhereInput[]
    id?: StringFilter<"comicalbums"> | string
    albumName?: StringFilter<"comicalbums"> | string
    comicList?: StringNullableListFilter<"comicalbums">
  }

  export type comicalbumsOrderByWithRelationInput = {
    id?: SortOrder
    albumName?: SortOrder
    comicList?: SortOrder
  }

  export type comicalbumsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comicalbumsWhereInput | comicalbumsWhereInput[]
    OR?: comicalbumsWhereInput[]
    NOT?: comicalbumsWhereInput | comicalbumsWhereInput[]
    albumName?: StringFilter<"comicalbums"> | string
    comicList?: StringNullableListFilter<"comicalbums">
  }, "id">

  export type comicalbumsOrderByWithAggregationInput = {
    id?: SortOrder
    albumName?: SortOrder
    comicList?: SortOrder
    _count?: comicalbumsCountOrderByAggregateInput
    _max?: comicalbumsMaxOrderByAggregateInput
    _min?: comicalbumsMinOrderByAggregateInput
  }

  export type comicalbumsScalarWhereWithAggregatesInput = {
    AND?: comicalbumsScalarWhereWithAggregatesInput | comicalbumsScalarWhereWithAggregatesInput[]
    OR?: comicalbumsScalarWhereWithAggregatesInput[]
    NOT?: comicalbumsScalarWhereWithAggregatesInput | comicalbumsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comicalbums"> | string
    albumName?: StringWithAggregatesFilter<"comicalbums"> | string
    comicList?: StringNullableListFilter<"comicalbums">
  }

  export type comicchaptersWhereInput = {
    AND?: comicchaptersWhereInput | comicchaptersWhereInput[]
    OR?: comicchaptersWhereInput[]
    NOT?: comicchaptersWhereInput | comicchaptersWhereInput[]
    id?: StringFilter<"comicchapters"> | string
    chapterName?: StringFilter<"comicchapters"> | string
    comments?: ComicchaptersCommentsCompositeListFilter | ComicchaptersCommentsObjectEqualityInput[]
    content?: StringNullableListFilter<"comicchapters">
    coverImage?: StringFilter<"comicchapters"> | string
    likes?: JsonNullableFilter<"comicchapters">
    publicTime?: DateTimeFilter<"comicchapters"> | Date | string
    unlockPrice?: IntFilter<"comicchapters"> | number
    userUnlocked?: JsonNullableFilter<"comicchapters">
    views?: IntFilter<"comicchapters"> | number
  }

  export type comicchaptersOrderByWithRelationInput = {
    id?: SortOrder
    chapterName?: SortOrder
    comments?: ComicchaptersCommentsOrderByCompositeAggregateInput
    content?: SortOrder
    coverImage?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    unlockPrice?: SortOrder
    userUnlocked?: SortOrder
    views?: SortOrder
  }

  export type comicchaptersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comicchaptersWhereInput | comicchaptersWhereInput[]
    OR?: comicchaptersWhereInput[]
    NOT?: comicchaptersWhereInput | comicchaptersWhereInput[]
    chapterName?: StringFilter<"comicchapters"> | string
    comments?: ComicchaptersCommentsCompositeListFilter | ComicchaptersCommentsObjectEqualityInput[]
    content?: StringNullableListFilter<"comicchapters">
    coverImage?: StringFilter<"comicchapters"> | string
    likes?: JsonNullableFilter<"comicchapters">
    publicTime?: DateTimeFilter<"comicchapters"> | Date | string
    unlockPrice?: IntFilter<"comicchapters"> | number
    userUnlocked?: JsonNullableFilter<"comicchapters">
    views?: IntFilter<"comicchapters"> | number
  }, "id">

  export type comicchaptersOrderByWithAggregationInput = {
    id?: SortOrder
    chapterName?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    unlockPrice?: SortOrder
    userUnlocked?: SortOrder
    views?: SortOrder
    _count?: comicchaptersCountOrderByAggregateInput
    _avg?: comicchaptersAvgOrderByAggregateInput
    _max?: comicchaptersMaxOrderByAggregateInput
    _min?: comicchaptersMinOrderByAggregateInput
    _sum?: comicchaptersSumOrderByAggregateInput
  }

  export type comicchaptersScalarWhereWithAggregatesInput = {
    AND?: comicchaptersScalarWhereWithAggregatesInput | comicchaptersScalarWhereWithAggregatesInput[]
    OR?: comicchaptersScalarWhereWithAggregatesInput[]
    NOT?: comicchaptersScalarWhereWithAggregatesInput | comicchaptersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comicchapters"> | string
    chapterName?: StringWithAggregatesFilter<"comicchapters"> | string
    content?: StringNullableListFilter<"comicchapters">
    coverImage?: StringWithAggregatesFilter<"comicchapters"> | string
    likes?: JsonNullableWithAggregatesFilter<"comicchapters">
    publicTime?: DateTimeWithAggregatesFilter<"comicchapters"> | Date | string
    unlockPrice?: IntWithAggregatesFilter<"comicchapters"> | number
    userUnlocked?: JsonNullableWithAggregatesFilter<"comicchapters">
    views?: IntWithAggregatesFilter<"comicchapters"> | number
  }

  export type comicsWhereInput = {
    AND?: comicsWhereInput | comicsWhereInput[]
    OR?: comicsWhereInput[]
    NOT?: comicsWhereInput | comicsWhereInput[]
    id?: StringFilter<"comics"> | string
    ageFor?: StringFilter<"comics"> | string
    artist?: StringFilter<"comics"> | string
    author?: StringFilter<"comics"> | string
    chapterList?: StringNullableListFilter<"comics">
    comicName?: StringFilter<"comics"> | string
    coverImage?: StringFilter<"comics"> | string
    description?: StringFilter<"comics"> | string
    genres?: StringNullableListFilter<"comics">
    landspaceImage?: StringFilter<"comics"> | string
    newChapterTime?: StringFilter<"comics"> | string
    publisher?: StringFilter<"comics"> | string
  }

  export type comicsOrderByWithRelationInput = {
    id?: SortOrder
    ageFor?: SortOrder
    artist?: SortOrder
    author?: SortOrder
    chapterList?: SortOrder
    comicName?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    newChapterTime?: SortOrder
    publisher?: SortOrder
  }

  export type comicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comicsWhereInput | comicsWhereInput[]
    OR?: comicsWhereInput[]
    NOT?: comicsWhereInput | comicsWhereInput[]
    ageFor?: StringFilter<"comics"> | string
    artist?: StringFilter<"comics"> | string
    author?: StringFilter<"comics"> | string
    chapterList?: StringNullableListFilter<"comics">
    comicName?: StringFilter<"comics"> | string
    coverImage?: StringFilter<"comics"> | string
    description?: StringFilter<"comics"> | string
    genres?: StringNullableListFilter<"comics">
    landspaceImage?: StringFilter<"comics"> | string
    newChapterTime?: StringFilter<"comics"> | string
    publisher?: StringFilter<"comics"> | string
  }, "id">

  export type comicsOrderByWithAggregationInput = {
    id?: SortOrder
    ageFor?: SortOrder
    artist?: SortOrder
    author?: SortOrder
    chapterList?: SortOrder
    comicName?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    newChapterTime?: SortOrder
    publisher?: SortOrder
    _count?: comicsCountOrderByAggregateInput
    _max?: comicsMaxOrderByAggregateInput
    _min?: comicsMinOrderByAggregateInput
  }

  export type comicsScalarWhereWithAggregatesInput = {
    AND?: comicsScalarWhereWithAggregatesInput | comicsScalarWhereWithAggregatesInput[]
    OR?: comicsScalarWhereWithAggregatesInput[]
    NOT?: comicsScalarWhereWithAggregatesInput | comicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comics"> | string
    ageFor?: StringWithAggregatesFilter<"comics"> | string
    artist?: StringWithAggregatesFilter<"comics"> | string
    author?: StringWithAggregatesFilter<"comics"> | string
    chapterList?: StringNullableListFilter<"comics">
    comicName?: StringWithAggregatesFilter<"comics"> | string
    coverImage?: StringWithAggregatesFilter<"comics"> | string
    description?: StringWithAggregatesFilter<"comics"> | string
    genres?: StringNullableListFilter<"comics">
    landspaceImage?: StringWithAggregatesFilter<"comics"> | string
    newChapterTime?: StringWithAggregatesFilter<"comics"> | string
    publisher?: StringWithAggregatesFilter<"comics"> | string
  }

  export type genresWhereInput = {
    AND?: genresWhereInput | genresWhereInput[]
    OR?: genresWhereInput[]
    NOT?: genresWhereInput | genresWhereInput[]
    id?: StringFilter<"genres"> | string
    genreName?: StringFilter<"genres"> | string
  }

  export type genresOrderByWithRelationInput = {
    id?: SortOrder
    genreName?: SortOrder
  }

  export type genresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: genresWhereInput | genresWhereInput[]
    OR?: genresWhereInput[]
    NOT?: genresWhereInput | genresWhereInput[]
    genreName?: StringFilter<"genres"> | string
  }, "id">

  export type genresOrderByWithAggregationInput = {
    id?: SortOrder
    genreName?: SortOrder
    _count?: genresCountOrderByAggregateInput
    _max?: genresMaxOrderByAggregateInput
    _min?: genresMinOrderByAggregateInput
  }

  export type genresScalarWhereWithAggregatesInput = {
    AND?: genresScalarWhereWithAggregatesInput | genresScalarWhereWithAggregatesInput[]
    OR?: genresScalarWhereWithAggregatesInput[]
    NOT?: genresScalarWhereWithAggregatesInput | genresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"genres"> | string
    genreName?: StringWithAggregatesFilter<"genres"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    v?: IntNullableFilter<"users"> | number | null
    authentication?: XOR<UsersAuthenticationNullableCompositeFilter, UsersAuthenticationObjectEqualityInput> | null
    avatar?: StringNullableFilter<"users"> | string | null
    bookmarkList?: XOR<UsersBookmarkListCompositeFilter, UsersBookmarkListObjectEqualityInput>
    coinPoint?: IntNullableFilter<"users"> | number | null
    histories?: XOR<UsersHistoriesCompositeFilter, UsersHistoriesObjectEqualityInput>
    paymentHistories?: JsonNullableFilter<"users">
    phone?: StringNullableFilter<"users"> | string | null
    userName?: StringNullableFilter<"users"> | string | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    v?: SortOrder
    authentication?: UsersAuthenticationOrderByInput
    avatar?: SortOrder
    bookmarkList?: UsersBookmarkListOrderByInput
    coinPoint?: SortOrder
    histories?: UsersHistoriesOrderByInput
    paymentHistories?: SortOrder
    phone?: SortOrder
    userName?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    v?: IntNullableFilter<"users"> | number | null
    authentication?: XOR<UsersAuthenticationNullableCompositeFilter, UsersAuthenticationObjectEqualityInput> | null
    avatar?: StringNullableFilter<"users"> | string | null
    bookmarkList?: XOR<UsersBookmarkListCompositeFilter, UsersBookmarkListObjectEqualityInput>
    coinPoint?: IntNullableFilter<"users"> | number | null
    histories?: XOR<UsersHistoriesCompositeFilter, UsersHistoriesObjectEqualityInput>
    paymentHistories?: JsonNullableFilter<"users">
    phone?: StringNullableFilter<"users"> | string | null
    userName?: StringNullableFilter<"users"> | string | null
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    v?: SortOrder
    avatar?: SortOrder
    coinPoint?: SortOrder
    paymentHistories?: SortOrder
    phone?: SortOrder
    userName?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    v?: IntNullableWithAggregatesFilter<"users"> | number | null
    avatar?: StringNullableWithAggregatesFilter<"users"> | string | null
    coinPoint?: IntNullableWithAggregatesFilter<"users"> | number | null
    paymentHistories?: JsonNullableWithAggregatesFilter<"users">
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    userName?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type animeepisodesCreateInput = {
    id?: string
    adLink: string
    advertising: string
    comments?: XOR<AnimeepisodesCommentsListCreateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content: string
    coverImage: string
    episodeName: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    totalTime: number
    views: number
  }

  export type animeepisodesUncheckedCreateInput = {
    id?: string
    adLink: string
    advertising: string
    comments?: XOR<AnimeepisodesCommentsListCreateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content: string
    coverImage: string
    episodeName: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    totalTime: number
    views: number
  }

  export type animeepisodesUpdateInput = {
    adLink?: StringFieldUpdateOperationsInput | string
    advertising?: StringFieldUpdateOperationsInput | string
    comments?: XOR<AnimeepisodesCommentsListUpdateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    episodeName?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTime?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
  }

  export type animeepisodesUncheckedUpdateInput = {
    adLink?: StringFieldUpdateOperationsInput | string
    advertising?: StringFieldUpdateOperationsInput | string
    comments?: XOR<AnimeepisodesCommentsListUpdateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    episodeName?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTime?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
  }

  export type animeepisodesCreateManyInput = {
    id?: string
    adLink: string
    advertising: string
    comments?: XOR<AnimeepisodesCommentsListCreateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content: string
    coverImage: string
    episodeName: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    totalTime: number
    views: number
  }

  export type animeepisodesUpdateManyMutationInput = {
    adLink?: StringFieldUpdateOperationsInput | string
    advertising?: StringFieldUpdateOperationsInput | string
    comments?: XOR<AnimeepisodesCommentsListUpdateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    episodeName?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTime?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
  }

  export type animeepisodesUncheckedUpdateManyInput = {
    adLink?: StringFieldUpdateOperationsInput | string
    advertising?: StringFieldUpdateOperationsInput | string
    comments?: XOR<AnimeepisodesCommentsListUpdateEnvelopeInput, AnimeepisodesCommentsCreateInput> | AnimeepisodesCommentsCreateInput[]
    content?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    episodeName?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    totalTime?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
  }

  export type animesCreateInput = {
    id?: string
    ageFor: string
    coverImage: string
    description: string
    episodes?: animesCreateepisodesInput | string[]
    genres?: animesCreategenresInput | string[]
    landspaceImage: string
    movieName: string
    publishTime: string
    publisher: string
  }

  export type animesUncheckedCreateInput = {
    id?: string
    ageFor: string
    coverImage: string
    description: string
    episodes?: animesCreateepisodesInput | string[]
    genres?: animesCreategenresInput | string[]
    landspaceImage: string
    movieName: string
    publishTime: string
    publisher: string
  }

  export type animesUpdateInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    episodes?: animesUpdateepisodesInput | string[]
    genres?: animesUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    movieName?: StringFieldUpdateOperationsInput | string
    publishTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type animesUncheckedUpdateInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    episodes?: animesUpdateepisodesInput | string[]
    genres?: animesUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    movieName?: StringFieldUpdateOperationsInput | string
    publishTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type animesCreateManyInput = {
    id?: string
    ageFor: string
    coverImage: string
    description: string
    episodes?: animesCreateepisodesInput | string[]
    genres?: animesCreategenresInput | string[]
    landspaceImage: string
    movieName: string
    publishTime: string
    publisher: string
  }

  export type animesUpdateManyMutationInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    episodes?: animesUpdateepisodesInput | string[]
    genres?: animesUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    movieName?: StringFieldUpdateOperationsInput | string
    publishTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type animesUncheckedUpdateManyInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    episodes?: animesUpdateepisodesInput | string[]
    genres?: animesUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    movieName?: StringFieldUpdateOperationsInput | string
    publishTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type bannersCreateInput = {
    id?: string
    list?: XOR<BannersListListCreateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type: string
  }

  export type bannersUncheckedCreateInput = {
    id?: string
    list?: XOR<BannersListListCreateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type: string
  }

  export type bannersUpdateInput = {
    list?: XOR<BannersListListUpdateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type?: StringFieldUpdateOperationsInput | string
  }

  export type bannersUncheckedUpdateInput = {
    list?: XOR<BannersListListUpdateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type?: StringFieldUpdateOperationsInput | string
  }

  export type bannersCreateManyInput = {
    id?: string
    list?: XOR<BannersListListCreateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type: string
  }

  export type bannersUpdateManyMutationInput = {
    list?: XOR<BannersListListUpdateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type?: StringFieldUpdateOperationsInput | string
  }

  export type bannersUncheckedUpdateManyInput = {
    list?: XOR<BannersListListUpdateEnvelopeInput, BannersListCreateInput> | BannersListCreateInput[]
    type?: StringFieldUpdateOperationsInput | string
  }

  export type comicalbumsCreateInput = {
    id?: string
    albumName: string
    comicList?: comicalbumsCreatecomicListInput | string[]
  }

  export type comicalbumsUncheckedCreateInput = {
    id?: string
    albumName: string
    comicList?: comicalbumsCreatecomicListInput | string[]
  }

  export type comicalbumsUpdateInput = {
    albumName?: StringFieldUpdateOperationsInput | string
    comicList?: comicalbumsUpdatecomicListInput | string[]
  }

  export type comicalbumsUncheckedUpdateInput = {
    albumName?: StringFieldUpdateOperationsInput | string
    comicList?: comicalbumsUpdatecomicListInput | string[]
  }

  export type comicalbumsCreateManyInput = {
    id?: string
    albumName: string
    comicList?: comicalbumsCreatecomicListInput | string[]
  }

  export type comicalbumsUpdateManyMutationInput = {
    albumName?: StringFieldUpdateOperationsInput | string
    comicList?: comicalbumsUpdatecomicListInput | string[]
  }

  export type comicalbumsUncheckedUpdateManyInput = {
    albumName?: StringFieldUpdateOperationsInput | string
    comicList?: comicalbumsUpdatecomicListInput | string[]
  }

  export type comicchaptersCreateInput = {
    id?: string
    chapterName: string
    comments?: XOR<ComicchaptersCommentsListCreateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersCreatecontentInput | string[]
    coverImage: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    unlockPrice: number
    userUnlocked?: InputJsonValue | null
    views: number
  }

  export type comicchaptersUncheckedCreateInput = {
    id?: string
    chapterName: string
    comments?: XOR<ComicchaptersCommentsListCreateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersCreatecontentInput | string[]
    coverImage: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    unlockPrice: number
    userUnlocked?: InputJsonValue | null
    views: number
  }

  export type comicchaptersUpdateInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    comments?: XOR<ComicchaptersCommentsListUpdateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersUpdatecontentInput | string[]
    coverImage?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockPrice?: IntFieldUpdateOperationsInput | number
    userUnlocked?: InputJsonValue | InputJsonValue | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type comicchaptersUncheckedUpdateInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    comments?: XOR<ComicchaptersCommentsListUpdateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersUpdatecontentInput | string[]
    coverImage?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockPrice?: IntFieldUpdateOperationsInput | number
    userUnlocked?: InputJsonValue | InputJsonValue | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type comicchaptersCreateManyInput = {
    id?: string
    chapterName: string
    comments?: XOR<ComicchaptersCommentsListCreateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersCreatecontentInput | string[]
    coverImage: string
    likes?: InputJsonValue | null
    publicTime: Date | string
    unlockPrice: number
    userUnlocked?: InputJsonValue | null
    views: number
  }

  export type comicchaptersUpdateManyMutationInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    comments?: XOR<ComicchaptersCommentsListUpdateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersUpdatecontentInput | string[]
    coverImage?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockPrice?: IntFieldUpdateOperationsInput | number
    userUnlocked?: InputJsonValue | InputJsonValue | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type comicchaptersUncheckedUpdateManyInput = {
    chapterName?: StringFieldUpdateOperationsInput | string
    comments?: XOR<ComicchaptersCommentsListUpdateEnvelopeInput, ComicchaptersCommentsCreateInput> | ComicchaptersCommentsCreateInput[]
    content?: comicchaptersUpdatecontentInput | string[]
    coverImage?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    publicTime?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockPrice?: IntFieldUpdateOperationsInput | number
    userUnlocked?: InputJsonValue | InputJsonValue | null
    views?: IntFieldUpdateOperationsInput | number
  }

  export type comicsCreateInput = {
    id?: string
    ageFor: string
    artist: string
    author: string
    chapterList?: comicsCreatechapterListInput | string[]
    comicName: string
    coverImage: string
    description: string
    genres?: comicsCreategenresInput | string[]
    landspaceImage: string
    newChapterTime: string
    publisher: string
  }

  export type comicsUncheckedCreateInput = {
    id?: string
    ageFor: string
    artist: string
    author: string
    chapterList?: comicsCreatechapterListInput | string[]
    comicName: string
    coverImage: string
    description: string
    genres?: comicsCreategenresInput | string[]
    landspaceImage: string
    newChapterTime: string
    publisher: string
  }

  export type comicsUpdateInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    chapterList?: comicsUpdatechapterListInput | string[]
    comicName?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    genres?: comicsUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    newChapterTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type comicsUncheckedUpdateInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    chapterList?: comicsUpdatechapterListInput | string[]
    comicName?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    genres?: comicsUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    newChapterTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type comicsCreateManyInput = {
    id?: string
    ageFor: string
    artist: string
    author: string
    chapterList?: comicsCreatechapterListInput | string[]
    comicName: string
    coverImage: string
    description: string
    genres?: comicsCreategenresInput | string[]
    landspaceImage: string
    newChapterTime: string
    publisher: string
  }

  export type comicsUpdateManyMutationInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    chapterList?: comicsUpdatechapterListInput | string[]
    comicName?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    genres?: comicsUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    newChapterTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type comicsUncheckedUpdateManyInput = {
    ageFor?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    chapterList?: comicsUpdatechapterListInput | string[]
    comicName?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    genres?: comicsUpdategenresInput | string[]
    landspaceImage?: StringFieldUpdateOperationsInput | string
    newChapterTime?: StringFieldUpdateOperationsInput | string
    publisher?: StringFieldUpdateOperationsInput | string
  }

  export type genresCreateInput = {
    id?: string
    genreName: string
  }

  export type genresUncheckedCreateInput = {
    id?: string
    genreName: string
  }

  export type genresUpdateInput = {
    genreName?: StringFieldUpdateOperationsInput | string
  }

  export type genresUncheckedUpdateInput = {
    genreName?: StringFieldUpdateOperationsInput | string
  }

  export type genresCreateManyInput = {
    id?: string
    genreName: string
  }

  export type genresUpdateManyMutationInput = {
    genreName?: StringFieldUpdateOperationsInput | string
  }

  export type genresUncheckedUpdateManyInput = {
    genreName?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    id?: string
    v?: number | null
    authentication?: XOR<UsersAuthenticationNullableCreateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: string | null
    bookmarkList: XOR<UsersBookmarkListCreateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: number | null
    histories: XOR<UsersHistoriesCreateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | null
    phone?: string | null
    userName?: string | null
  }

  export type usersUncheckedCreateInput = {
    id?: string
    v?: number | null
    authentication?: XOR<UsersAuthenticationNullableCreateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: string | null
    bookmarkList: XOR<UsersBookmarkListCreateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: number | null
    histories: XOR<UsersHistoriesCreateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | null
    phone?: string | null
    userName?: string | null
  }

  export type usersUpdateInput = {
    v?: NullableIntFieldUpdateOperationsInput | number | null
    authentication?: XOR<UsersAuthenticationNullableUpdateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarkList?: XOR<UsersBookmarkListUpdateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: NullableIntFieldUpdateOperationsInput | number | null
    histories?: XOR<UsersHistoriesUpdateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | InputJsonValue | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateInput = {
    v?: NullableIntFieldUpdateOperationsInput | number | null
    authentication?: XOR<UsersAuthenticationNullableUpdateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarkList?: XOR<UsersBookmarkListUpdateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: NullableIntFieldUpdateOperationsInput | number | null
    histories?: XOR<UsersHistoriesUpdateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | InputJsonValue | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateManyInput = {
    id?: string
    v?: number | null
    authentication?: XOR<UsersAuthenticationNullableCreateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: string | null
    bookmarkList: XOR<UsersBookmarkListCreateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: number | null
    histories: XOR<UsersHistoriesCreateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | null
    phone?: string | null
    userName?: string | null
  }

  export type usersUpdateManyMutationInput = {
    v?: NullableIntFieldUpdateOperationsInput | number | null
    authentication?: XOR<UsersAuthenticationNullableUpdateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarkList?: XOR<UsersBookmarkListUpdateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: NullableIntFieldUpdateOperationsInput | number | null
    histories?: XOR<UsersHistoriesUpdateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | InputJsonValue | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    v?: NullableIntFieldUpdateOperationsInput | number | null
    authentication?: XOR<UsersAuthenticationNullableUpdateEnvelopeInput, UsersAuthenticationCreateInput> | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bookmarkList?: XOR<UsersBookmarkListUpdateEnvelopeInput, UsersBookmarkListCreateInput>
    coinPoint?: NullableIntFieldUpdateOperationsInput | number | null
    histories?: XOR<UsersHistoriesUpdateEnvelopeInput, UsersHistoriesCreateInput>
    paymentHistories?: InputJsonValue | InputJsonValue | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AnimeepisodesCommentsCompositeListFilter = {
    equals?: AnimeepisodesCommentsObjectEqualityInput[]
    every?: AnimeepisodesCommentsWhereInput
    some?: AnimeepisodesCommentsWhereInput
    none?: AnimeepisodesCommentsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AnimeepisodesCommentsObjectEqualityInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: AnimeepisodesCommentsRepliesObjectEqualityInput[]
    userId: string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AnimeepisodesCommentsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type animeepisodesCountOrderByAggregateInput = {
    id?: SortOrder
    adLink?: SortOrder
    advertising?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    episodeName?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type animeepisodesAvgOrderByAggregateInput = {
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type animeepisodesMaxOrderByAggregateInput = {
    id?: SortOrder
    adLink?: SortOrder
    advertising?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    episodeName?: SortOrder
    publicTime?: SortOrder
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type animeepisodesMinOrderByAggregateInput = {
    id?: SortOrder
    adLink?: SortOrder
    advertising?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    episodeName?: SortOrder
    publicTime?: SortOrder
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type animeepisodesSumOrderByAggregateInput = {
    totalTime?: SortOrder
    views?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type animesCountOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    episodes?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    movieName?: SortOrder
    publishTime?: SortOrder
    publisher?: SortOrder
  }

  export type animesMaxOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    landspaceImage?: SortOrder
    movieName?: SortOrder
    publishTime?: SortOrder
    publisher?: SortOrder
  }

  export type animesMinOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    landspaceImage?: SortOrder
    movieName?: SortOrder
    publishTime?: SortOrder
    publisher?: SortOrder
  }

  export type BannersListCompositeListFilter = {
    equals?: BannersListObjectEqualityInput[]
    every?: BannersListWhereInput
    some?: BannersListWhereInput
    none?: BannersListWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type BannersListObjectEqualityInput = {
    bannerImage: string
    urlId: string
  }

  export type BannersListOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type bannersCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type bannersMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type bannersMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type comicalbumsCountOrderByAggregateInput = {
    id?: SortOrder
    albumName?: SortOrder
    comicList?: SortOrder
  }

  export type comicalbumsMaxOrderByAggregateInput = {
    id?: SortOrder
    albumName?: SortOrder
  }

  export type comicalbumsMinOrderByAggregateInput = {
    id?: SortOrder
    albumName?: SortOrder
  }

  export type ComicchaptersCommentsCompositeListFilter = {
    equals?: ComicchaptersCommentsObjectEqualityInput[]
    every?: ComicchaptersCommentsWhereInput
    some?: ComicchaptersCommentsWhereInput
    none?: ComicchaptersCommentsWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ComicchaptersCommentsObjectEqualityInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: ComicchaptersCommentsRepliesObjectEqualityInput[]
    userId: string
  }

  export type ComicchaptersCommentsOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type comicchaptersCountOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    content?: SortOrder
    coverImage?: SortOrder
    likes?: SortOrder
    publicTime?: SortOrder
    unlockPrice?: SortOrder
    userUnlocked?: SortOrder
    views?: SortOrder
  }

  export type comicchaptersAvgOrderByAggregateInput = {
    unlockPrice?: SortOrder
    views?: SortOrder
  }

  export type comicchaptersMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    coverImage?: SortOrder
    publicTime?: SortOrder
    unlockPrice?: SortOrder
    views?: SortOrder
  }

  export type comicchaptersMinOrderByAggregateInput = {
    id?: SortOrder
    chapterName?: SortOrder
    coverImage?: SortOrder
    publicTime?: SortOrder
    unlockPrice?: SortOrder
    views?: SortOrder
  }

  export type comicchaptersSumOrderByAggregateInput = {
    unlockPrice?: SortOrder
    views?: SortOrder
  }

  export type comicsCountOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    artist?: SortOrder
    author?: SortOrder
    chapterList?: SortOrder
    comicName?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    genres?: SortOrder
    landspaceImage?: SortOrder
    newChapterTime?: SortOrder
    publisher?: SortOrder
  }

  export type comicsMaxOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    artist?: SortOrder
    author?: SortOrder
    comicName?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    landspaceImage?: SortOrder
    newChapterTime?: SortOrder
    publisher?: SortOrder
  }

  export type comicsMinOrderByAggregateInput = {
    id?: SortOrder
    ageFor?: SortOrder
    artist?: SortOrder
    author?: SortOrder
    comicName?: SortOrder
    coverImage?: SortOrder
    description?: SortOrder
    landspaceImage?: SortOrder
    newChapterTime?: SortOrder
    publisher?: SortOrder
  }

  export type genresCountOrderByAggregateInput = {
    id?: SortOrder
    genreName?: SortOrder
  }

  export type genresMaxOrderByAggregateInput = {
    id?: SortOrder
    genreName?: SortOrder
  }

  export type genresMinOrderByAggregateInput = {
    id?: SortOrder
    genreName?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type UsersAuthenticationNullableCompositeFilter = {
    equals?: UsersAuthenticationObjectEqualityInput | null
    is?: UsersAuthenticationWhereInput | null
    isNot?: UsersAuthenticationWhereInput | null
    isSet?: boolean
  }

  export type UsersAuthenticationObjectEqualityInput = {
    password: string
    salt: string
    sessionToken: string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UsersBookmarkListCompositeFilter = {
    equals?: UsersBookmarkListObjectEqualityInput
    is?: UsersBookmarkListWhereInput
    isNot?: UsersBookmarkListWhereInput
  }

  export type UsersBookmarkListObjectEqualityInput = {
    comic?: InputJsonValue | null
    movies?: InputJsonValue | null
  }

  export type UsersHistoriesCompositeFilter = {
    equals?: UsersHistoriesObjectEqualityInput
    is?: UsersHistoriesWhereInput
    isNot?: UsersHistoriesWhereInput
  }

  export type UsersHistoriesObjectEqualityInput = {
    readingComic?: InputJsonValue | null
    watchingMovie?: InputJsonValue | null
  }

  export type UsersAuthenticationOrderByInput = {
    password?: SortOrder
    salt?: SortOrder
    sessionToken?: SortOrder
  }

  export type UsersBookmarkListOrderByInput = {
    comic?: SortOrder
    movies?: SortOrder
  }

  export type UsersHistoriesOrderByInput = {
    readingComic?: SortOrder
    watchingMovie?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    avatar?: SortOrder
    coinPoint?: SortOrder
    paymentHistories?: SortOrder
    phone?: SortOrder
    userName?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    v?: SortOrder
    coinPoint?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    avatar?: SortOrder
    coinPoint?: SortOrder
    phone?: SortOrder
    userName?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    avatar?: SortOrder
    coinPoint?: SortOrder
    phone?: SortOrder
    userName?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    v?: SortOrder
    coinPoint?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AnimeepisodesCommentsListCreateEnvelopeInput = {
    set?: AnimeepisodesCommentsCreateInput | AnimeepisodesCommentsCreateInput[]
  }

  export type AnimeepisodesCommentsCreateInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: AnimeepisodesCommentsRepliesCreateInput | AnimeepisodesCommentsRepliesCreateInput[]
    userId: string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AnimeepisodesCommentsListUpdateEnvelopeInput = {
    set?: AnimeepisodesCommentsCreateInput | AnimeepisodesCommentsCreateInput[]
    push?: AnimeepisodesCommentsCreateInput | AnimeepisodesCommentsCreateInput[]
    updateMany?: AnimeepisodesCommentsUpdateManyInput
    deleteMany?: AnimeepisodesCommentsDeleteManyInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type animesCreateepisodesInput = {
    set: string[]
  }

  export type animesCreategenresInput = {
    set: string[]
  }

  export type animesUpdateepisodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type animesUpdategenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BannersListListCreateEnvelopeInput = {
    set?: BannersListCreateInput | BannersListCreateInput[]
  }

  export type BannersListCreateInput = {
    bannerImage: string
    urlId: string
  }

  export type BannersListListUpdateEnvelopeInput = {
    set?: BannersListCreateInput | BannersListCreateInput[]
    push?: BannersListCreateInput | BannersListCreateInput[]
    updateMany?: BannersListUpdateManyInput
    deleteMany?: BannersListDeleteManyInput
  }

  export type comicalbumsCreatecomicListInput = {
    set: string[]
  }

  export type comicalbumsUpdatecomicListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ComicchaptersCommentsListCreateEnvelopeInput = {
    set?: ComicchaptersCommentsCreateInput | ComicchaptersCommentsCreateInput[]
  }

  export type ComicchaptersCommentsCreateInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: ComicchaptersCommentsRepliesCreateInput | ComicchaptersCommentsRepliesCreateInput[]
    userId: string
  }

  export type comicchaptersCreatecontentInput = {
    set: string[]
  }

  export type ComicchaptersCommentsListUpdateEnvelopeInput = {
    set?: ComicchaptersCommentsCreateInput | ComicchaptersCommentsCreateInput[]
    push?: ComicchaptersCommentsCreateInput | ComicchaptersCommentsCreateInput[]
    updateMany?: ComicchaptersCommentsUpdateManyInput
    deleteMany?: ComicchaptersCommentsDeleteManyInput
  }

  export type comicchaptersUpdatecontentInput = {
    set?: string[]
    push?: string | string[]
  }

  export type comicsCreatechapterListInput = {
    set: string[]
  }

  export type comicsCreategenresInput = {
    set: string[]
  }

  export type comicsUpdatechapterListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type comicsUpdategenresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UsersAuthenticationNullableCreateEnvelopeInput = {
    set?: UsersAuthenticationCreateInput | null
  }

  export type UsersAuthenticationCreateInput = {
    password: string
    salt: string
    sessionToken: string
  }

  export type UsersBookmarkListCreateEnvelopeInput = {
    set?: UsersBookmarkListCreateInput
  }

  export type UsersBookmarkListCreateInput = {
    comic?: InputJsonValue | null
    movies?: InputJsonValue | null
  }

  export type UsersHistoriesCreateEnvelopeInput = {
    set?: UsersHistoriesCreateInput
  }

  export type UsersHistoriesCreateInput = {
    readingComic?: InputJsonValue | null
    watchingMovie?: InputJsonValue | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UsersAuthenticationNullableUpdateEnvelopeInput = {
    set?: UsersAuthenticationCreateInput | null
    upsert?: UsersAuthenticationUpsertInput
    unset?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type UsersBookmarkListUpdateEnvelopeInput = {
    set?: UsersBookmarkListCreateInput
    update?: UsersBookmarkListUpdateInput
  }

  export type UsersHistoriesUpdateEnvelopeInput = {
    set?: UsersHistoriesCreateInput
    update?: UsersHistoriesUpdateInput
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AnimeepisodesCommentsWhereInput = {
    AND?: AnimeepisodesCommentsWhereInput | AnimeepisodesCommentsWhereInput[]
    OR?: AnimeepisodesCommentsWhereInput[]
    NOT?: AnimeepisodesCommentsWhereInput | AnimeepisodesCommentsWhereInput[]
    content?: StringFilter<"AnimeepisodesComments"> | string
    likes?: JsonNullableFilter<"AnimeepisodesComments">
    replies?: AnimeepisodesCommentsRepliesCompositeListFilter | AnimeepisodesCommentsRepliesObjectEqualityInput[]
    userId?: StringFilter<"AnimeepisodesComments"> | string
  }

  export type AnimeepisodesCommentsRepliesObjectEqualityInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: InputJsonValue | null
    userId: string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BannersListWhereInput = {
    AND?: BannersListWhereInput | BannersListWhereInput[]
    OR?: BannersListWhereInput[]
    NOT?: BannersListWhereInput | BannersListWhereInput[]
    bannerImage?: StringFilter<"BannersList"> | string
    urlId?: StringFilter<"BannersList"> | string
  }

  export type ComicchaptersCommentsWhereInput = {
    AND?: ComicchaptersCommentsWhereInput | ComicchaptersCommentsWhereInput[]
    OR?: ComicchaptersCommentsWhereInput[]
    NOT?: ComicchaptersCommentsWhereInput | ComicchaptersCommentsWhereInput[]
    content?: StringFilter<"ComicchaptersComments"> | string
    likes?: JsonNullableFilter<"ComicchaptersComments">
    replies?: ComicchaptersCommentsRepliesCompositeListFilter | ComicchaptersCommentsRepliesObjectEqualityInput[]
    userId?: StringFilter<"ComicchaptersComments"> | string
  }

  export type ComicchaptersCommentsRepliesObjectEqualityInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: InputJsonValue | null
    userId: string
  }

  export type UsersAuthenticationWhereInput = {
    AND?: UsersAuthenticationWhereInput | UsersAuthenticationWhereInput[]
    OR?: UsersAuthenticationWhereInput[]
    NOT?: UsersAuthenticationWhereInput | UsersAuthenticationWhereInput[]
    password?: StringFilter<"UsersAuthentication"> | string
    salt?: StringFilter<"UsersAuthentication"> | string
    sessionToken?: StringFilter<"UsersAuthentication"> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UsersBookmarkListWhereInput = {
    AND?: UsersBookmarkListWhereInput | UsersBookmarkListWhereInput[]
    OR?: UsersBookmarkListWhereInput[]
    NOT?: UsersBookmarkListWhereInput | UsersBookmarkListWhereInput[]
    comic?: JsonNullableFilter<"UsersBookmarkList">
    movies?: JsonNullableFilter<"UsersBookmarkList">
  }

  export type UsersHistoriesWhereInput = {
    AND?: UsersHistoriesWhereInput | UsersHistoriesWhereInput[]
    OR?: UsersHistoriesWhereInput[]
    NOT?: UsersHistoriesWhereInput | UsersHistoriesWhereInput[]
    readingComic?: JsonNullableFilter<"UsersHistories">
    watchingMovie?: JsonNullableFilter<"UsersHistories">
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type AnimeepisodesCommentsRepliesCreateInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: InputJsonValue | null
    userId: string
  }

  export type AnimeepisodesCommentsUpdateManyInput = {
    where: AnimeepisodesCommentsWhereInput
    data: AnimeepisodesCommentsUpdateInput
  }

  export type AnimeepisodesCommentsDeleteManyInput = {
    where: AnimeepisodesCommentsWhereInput
  }

  export type BannersListUpdateManyInput = {
    where: BannersListWhereInput
    data: BannersListUpdateInput
  }

  export type BannersListDeleteManyInput = {
    where: BannersListWhereInput
  }

  export type ComicchaptersCommentsRepliesCreateInput = {
    content: string
    likes?: InputJsonValue | null
    replies?: InputJsonValue | null
    userId: string
  }

  export type ComicchaptersCommentsUpdateManyInput = {
    where: ComicchaptersCommentsWhereInput
    data: ComicchaptersCommentsUpdateInput
  }

  export type ComicchaptersCommentsDeleteManyInput = {
    where: ComicchaptersCommentsWhereInput
  }

  export type UsersAuthenticationUpsertInput = {
    set: UsersAuthenticationCreateInput | null
    update: UsersAuthenticationUpdateInput
  }

  export type UsersBookmarkListUpdateInput = {
    comic?: InputJsonValue | InputJsonValue | null
    movies?: InputJsonValue | InputJsonValue | null
  }

  export type UsersHistoriesUpdateInput = {
    readingComic?: InputJsonValue | InputJsonValue | null
    watchingMovie?: InputJsonValue | InputJsonValue | null
  }

  export type AnimeepisodesCommentsRepliesCompositeListFilter = {
    equals?: AnimeepisodesCommentsRepliesObjectEqualityInput[]
    every?: AnimeepisodesCommentsRepliesWhereInput
    some?: AnimeepisodesCommentsRepliesWhereInput
    none?: AnimeepisodesCommentsRepliesWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type ComicchaptersCommentsRepliesCompositeListFilter = {
    equals?: ComicchaptersCommentsRepliesObjectEqualityInput[]
    every?: ComicchaptersCommentsRepliesWhereInput
    some?: ComicchaptersCommentsRepliesWhereInput
    none?: ComicchaptersCommentsRepliesWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type AnimeepisodesCommentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    replies?: XOR<AnimeepisodesCommentsRepliesListUpdateEnvelopeInput, AnimeepisodesCommentsRepliesCreateInput> | AnimeepisodesCommentsRepliesCreateInput[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BannersListUpdateInput = {
    bannerImage?: StringFieldUpdateOperationsInput | string
    urlId?: StringFieldUpdateOperationsInput | string
  }

  export type ComicchaptersCommentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    replies?: XOR<ComicchaptersCommentsRepliesListUpdateEnvelopeInput, ComicchaptersCommentsRepliesCreateInput> | ComicchaptersCommentsRepliesCreateInput[]
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersAuthenticationUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
  }

  export type AnimeepisodesCommentsRepliesWhereInput = {
    AND?: AnimeepisodesCommentsRepliesWhereInput | AnimeepisodesCommentsRepliesWhereInput[]
    OR?: AnimeepisodesCommentsRepliesWhereInput[]
    NOT?: AnimeepisodesCommentsRepliesWhereInput | AnimeepisodesCommentsRepliesWhereInput[]
    content?: StringFilter<"AnimeepisodesCommentsReplies"> | string
    likes?: JsonNullableFilter<"AnimeepisodesCommentsReplies">
    replies?: JsonNullableFilter<"AnimeepisodesCommentsReplies">
    userId?: StringFilter<"AnimeepisodesCommentsReplies"> | string
  }

  export type ComicchaptersCommentsRepliesWhereInput = {
    AND?: ComicchaptersCommentsRepliesWhereInput | ComicchaptersCommentsRepliesWhereInput[]
    OR?: ComicchaptersCommentsRepliesWhereInput[]
    NOT?: ComicchaptersCommentsRepliesWhereInput | ComicchaptersCommentsRepliesWhereInput[]
    content?: StringFilter<"ComicchaptersCommentsReplies"> | string
    likes?: JsonNullableFilter<"ComicchaptersCommentsReplies">
    replies?: JsonNullableFilter<"ComicchaptersCommentsReplies">
    userId?: StringFilter<"ComicchaptersCommentsReplies"> | string
  }

  export type AnimeepisodesCommentsRepliesListUpdateEnvelopeInput = {
    set?: AnimeepisodesCommentsRepliesCreateInput | AnimeepisodesCommentsRepliesCreateInput[]
    push?: AnimeepisodesCommentsRepliesCreateInput | AnimeepisodesCommentsRepliesCreateInput[]
    updateMany?: AnimeepisodesCommentsRepliesUpdateManyInput
    deleteMany?: AnimeepisodesCommentsRepliesDeleteManyInput
  }

  export type ComicchaptersCommentsRepliesListUpdateEnvelopeInput = {
    set?: ComicchaptersCommentsRepliesCreateInput | ComicchaptersCommentsRepliesCreateInput[]
    push?: ComicchaptersCommentsRepliesCreateInput | ComicchaptersCommentsRepliesCreateInput[]
    updateMany?: ComicchaptersCommentsRepliesUpdateManyInput
    deleteMany?: ComicchaptersCommentsRepliesDeleteManyInput
  }

  export type AnimeepisodesCommentsRepliesUpdateManyInput = {
    where: AnimeepisodesCommentsRepliesWhereInput
    data: AnimeepisodesCommentsRepliesUpdateInput
  }

  export type AnimeepisodesCommentsRepliesDeleteManyInput = {
    where: AnimeepisodesCommentsRepliesWhereInput
  }

  export type ComicchaptersCommentsRepliesUpdateManyInput = {
    where: ComicchaptersCommentsRepliesWhereInput
    data: ComicchaptersCommentsRepliesUpdateInput
  }

  export type ComicchaptersCommentsRepliesDeleteManyInput = {
    where: ComicchaptersCommentsRepliesWhereInput
  }

  export type AnimeepisodesCommentsRepliesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    replies?: InputJsonValue | InputJsonValue | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ComicchaptersCommentsRepliesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: InputJsonValue | InputJsonValue | null
    replies?: InputJsonValue | InputJsonValue | null
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AnimeepisodesCommentsDefaultArgs instead
     */
    export type AnimeepisodesCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnimeepisodesCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnimeepisodesCommentsRepliesDefaultArgs instead
     */
    export type AnimeepisodesCommentsRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnimeepisodesCommentsRepliesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannersListDefaultArgs instead
     */
    export type BannersListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannersListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComicchaptersCommentsDefaultArgs instead
     */
    export type ComicchaptersCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComicchaptersCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComicchaptersCommentsRepliesDefaultArgs instead
     */
    export type ComicchaptersCommentsRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComicchaptersCommentsRepliesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersAuthenticationDefaultArgs instead
     */
    export type UsersAuthenticationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersAuthenticationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersBookmarkListDefaultArgs instead
     */
    export type UsersBookmarkListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersBookmarkListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersHistoriesDefaultArgs instead
     */
    export type UsersHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersHistoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use animeepisodesDefaultArgs instead
     */
    export type animeepisodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = animeepisodesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use animesDefaultArgs instead
     */
    export type animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = animesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bannersDefaultArgs instead
     */
    export type bannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bannersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comicalbumsDefaultArgs instead
     */
    export type comicalbumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comicalbumsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comicchaptersDefaultArgs instead
     */
    export type comicchaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comicchaptersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comicsDefaultArgs instead
     */
    export type comicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use genresDefaultArgs instead
     */
    export type genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = genresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}